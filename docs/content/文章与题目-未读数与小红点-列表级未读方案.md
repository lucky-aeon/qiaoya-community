 # 文章与题目未读数（小红点）技术方案（列表级未读）

 作者：后端
 最后更新：2025-10-20
 状态：设计稿（可落地）
 适用范围：前台导航栏的“文章/题目/课程章节”未读数小红点展示与清零
 关键代码路径（规划）：
 - 领域层：`org.xhy.community.domain.read.*`（Last Seen 记录与读写规则）
 - 领域层：`org.xhy.community.domain.post.service.PostDomainService`（计数能力）
 - 领域层：`org.xhy.community.domain.interview.service.InterviewQuestionDomainService`（计数能力）
 - 领域层：`org.xhy.community.domain.course.service.ChapterDomainService`（计数能力）
 - 应用层：`org.xhy.community.application.read.service.UnreadAppService`（编排汇总与清零）

 ## 1. 背景与目标

 - 目标：在前端“文章”和“题目”的导航入口显示小红点，提示“自上次看过列表以来出现的新内容数量”。
 - 约束：不做逐条已读；不在列表项上显示“已读/未读”标识；仅用于导航级提示。
 - 现状：项目采用DDD + MyBatis Plus，现有 Post/Interview 领域服务具备分页与条件查询能力，可直接支撑基于时间窗口的数量统计。

 ## 2. 术语与口径

 - 列表级未读（Last Seen）：
   - 定义：自用户“上次访问该列表页面”的时间点起，到当前为止新出现的可见内容数量。
   - 行为：进入列表页后清零（以后端给定的 `serverNow` 时间点更新 lastSeen）。
 - 逐条已读（Read Marker）：为每一条内容记录 user×content 的“已读”关系；本方案不采用，仅在未来需要列表项已读态时再扩展。

 本方案“红点数字=新内容数量”，不是“未看过的条目数”的严格统计。

 ## 3. 拍板决策（已确认）

 - 计数口径：仅按“创建时间”（新发布才算新；编辑不触发红点）。
 - 首次访问策略：默认清零（首次生成 lastSeen=当前时间，避免历史海量红点）。
 - 清零时机：进入对应列表页即清零；以服务端 `serverNow` 返回并由客户端带回确认，避免抖动。
 - 管理端小红点：默认不做。若未来需要，推荐做“待审核数量/待处理数量”，与前台口径分离。

 ## 4. 架构设计与分层落位

 遵循项目分层规范与命名规范：Application 只编排，Domain 执行业务规则，Repository 继承 BaseMapper；枚举/类型需配置 TypeHandler。

 ### 4.1 领域模型（Domain）

 - 枚举：`ReadChannel`（位于 `org.xhy.community.domain.common.valueobject`）
   - 取值：`POSTS`, `QUESTIONS`, `CHAPTERS`
   - 说明：作为 `UserLastSeenEntity.channel` 的枚举字段，需在 `MyBatisTypeHandlerConfig` 注册枚举处理器。

 - 实体：`UserLastSeenEntity`（位于 `org.xhy.community.domain.read.entity`）
   - 字段：`id:String, userId:String, channel:ReadChannel, lastSeenAt:LocalDateTime, createTime, updateTime, deleted`

 - 仓储：`UserLastSeenRepository extends BaseMapper<UserLastSeenEntity>`（位于 `org.xhy.community.domain.read.repository`）

 - 领域服务：`ReadDomainService`（位于 `org.xhy.community.domain.read.service`）
   - 能力：
     - `getOrInit(userId, channel)`：若无记录则以“当前时间”初始化（首次访问策略）。
     - `updateLastSeen(userId, channel, serverNow)`：幂等更新，避免回拨（仅当 `serverNow >= lastSeenAt` 时更新）。
   - 注意：不做参数格式校验；仅做业务规则（幂等/回拨防护）。

 - 计数提供方（复用现有领域服务能力）：
   - `PostDomainService.countPublishedSince(Instant since)`：统计 `status = PUBLISHED` 且 `publish_time > since` 的数量。
   - `InterviewQuestionDomainService.countPublishedSince(Instant since)`：统计已发布题目数量（`publish_time > since`）。
   - `ChapterDomainService.countSince(Instant since)`：统计创建时间 `create_time > since` 的章节数量（全站）。

 ### 4.2 应用层（Application）

 - DTO：`UnreadSummaryDTO { Long postsUnread; Long questionsUnread; Long chaptersUnread; }`
 - Assembler：`UnreadAssembler`（静态方法，BeanUtils.copy）
 - 应用服务：`UnreadAppService`
   - `UnreadSummaryDTO getUnreadSummary(String userId)`：
     - 读取三个频道的 lastSeen
     - 调用 Post/Interview/Chapter 领域服务的“自某时以来统计”能力
     - 组装返回 DTO
   - `void visitChannel(String userId, ReadChannel channel, LocalDateTime serverNow)`：
     - 用 `serverNow` 幂等更新该频道 lastSeen（进入列表页后调用）

 说明：UserContext 仅在 Controller 层使用，向 AppService 传入 `String userId`。

 ## 5. 数据库与索引

 - 新表：`user_last_seen`
   - 列：`id VARCHAR(36) PK`, `user_id VARCHAR(36)`, `channel VARCHAR(20)`, `last_seen_at TIMESTAMP`, `create_time`, `update_time`, `deleted BOOLEAN`
   - 约束：唯一键 `(user_id, channel)`
 - 建议索引：
   - 文章表：`(status, create_time)` 复合索引
   - 题目表：`(status, create_time)` 复合索引
   - `user_last_seen`：唯一索引 `(user_id, channel)`
 - Flyway：
   - 路径：`src/main/resources/db/migration`
   - 命名：`Vxx__Create_user_last_seen.sql`
   - 语法：PostgreSQL；仅高频查询字段建索引（遵循项目规范）

 ## 6. 接口契约（对前端）

 说明：当前项目暂不实现 Controller；以下为推荐 API 形态，便于前后端对齐。Controller 层完成参数校验；App 层不做参数格式校验。

 - 获取未读汇总（导航）
   - `GET /api/user/unread/summary`
   - 响应：`{ postsUnread: number, questionsUnread: number, chaptersUnread: number }`

 - 标记访问某频道（进入列表页后调用）
   - `PUT /api/user/unread/visit?channel=POSTS|QUESTIONS|CHAPTERS`
   - 语义：以服务端 `serverNow` 为准更新 lastSeen；可设计为服务端生成 `serverNow` 并直接更新（前端无需回传）。

 可选：也可以把“清零”动作合入列表查询接口，由后端统一使用一次性的 `serverNow` 完成“查询+清零”。

 ## 7. 并发与幂等

 - 并发进入列表：以数据库层的“更新时比较时间”策略防止回拨（`WHERE serverNow >= last_seen_at`），保证单调不减。
 - 重复调用 visit：幂等；无副作用。
 - 时钟一致性：以服务端时间为准，避免客户端时钟偏差导致的小抖动。

 ## 8. 权限与可见性

 - 仅统计“已发布/可见”的内容；草稿、软删除不计入（系统已全局处理软删除忽略）。
 - 如未来在管理员后台展示红点，建议改为“待审核/待处理数”而非“新内容数”，并通过 `AccessLevel.ADMIN` 在 Domain 层分支处理。

 ## 9. 前端交互与时序

 - 登录后/路由切换到主导航：调用“未读汇总”接口，展示小红点；可每 30–60s 轮询刷新。
 - 进入文章/题目列表页：
   - 方案A（更通用）：列表接口返回 `serverNow`，前端随后调用“visitChannel(channel)”触发清零。
   - 方案B（更简洁）：进入列表页即调用“visitChannel(channel)”，后端内部使用服务端当前时间更新。
 - 跨端一致：lastSeen 存服务端，任一设备进入列表都会清零。

 ## 10. 迁移与落地步骤

 1) 新增 `docs/content` 方案文档（当前文档）。
 2) Flyway 新增 `user_last_seen` 表与唯一索引。
 3) Domain：新增 `read` 子域（实体/仓储/领域服务）；在 `MyBatisTypeHandlerConfig` 注册 `ReadChannel` 枚举。
 4) Application：新增 `UnreadAppService` 与 `UnreadAssembler/UnreadSummaryDTO`。
 5) Interface：新增 Controller 暴露两个接口（汇总/清零）。
 6) 前端：导航栏请求汇总接口；进入列表页调用清零；按需定时轮询。

 ## 11. 性能与容量评估

 - 存储：每用户每频道 1 条记录，常数级增长。
 - 读：导航一次 3 次 COUNT（文章/题目/章节）+ 1 次 lastSeen 读取；索引后可控。
 - 写：进入列表一次 upsert/更新，低频。
 - 备选优化：热点用户可做短期缓存；但 COUNT 受过滤条件影响，先以索引为主。

 ## 12. 风险与边界

 - 边界：在“仅按创建时间”口径下，内容小编辑不会触发红点；若未来要纳入“重大更新”，可增加“可见时间/重要更新时间”字段并切换口径。
 - 风险：首次访问清零可能降低“召回”效果；如需活动拉回，可人为下调 lastSeen 批量触发红点（运营策略）。
 - 一致性：计数使用 `>` vs `>=` 需统一（建议 `>`）；列表清零以 `serverNow` 为准，避免边界条目误差。

 ## 13. 可演进路线（需要逐条已读时）

 - 新增 `user_content_read`（userId, contentType[POST/QUESTION], contentId, readAt）唯一索引 `(user_id, content_type, content_id)`。
 - 列表项展示已读态；未读数可继续用 Last Seen，或切换为“可见总数 − 已读数”。
 - 仅保留最近 N 天/最近 N 条的读标记，控制存储与查询成本。

 ---

 附：本方案完全符合当前项目的 DDD 分层约束与编码规范：
 - Application 仅编排；Domain 只做业务规则；Repository 直接继承 BaseMapper；Assembler 使用静态方法 + BeanUtils.copy。
 - UserContext 仅限 Controller 层；ID 统一使用 `String` 与 UUID 主键；软删除在查询中已全局忽略。
 - 如需权限区分，按需在 Domain 层增加 `AccessLevel` 分支控制查询范围。
