# 敲鸭社区 SSO 单点登录对接文档

## 📋 目录

- [概述](#概述)
- [接入前准备](#接入前准备)
- [授权流程](#授权流程)
- [接口规范](#接口规范)
- [接口详情](#接口详情)
- [代码示例](#代码示例)
- [错误处理](#错误处理)
- [常见问题](#常见问题)

---

## 概述

敲鸭社区提供基于 **OAuth 2.0 + OpenID Connect (OIDC)** 标准的单点登录服务，支持第三方应用通过标准协议接入用户认证与授权功能。

### 核心特性

- ✅ 基于 OAuth 2.0 授权码模式（Authorization Code Flow）
- ✅ 支持 PKCE 安全增强（推荐）
- ✅ 符合 OpenID Connect 规范
- ✅ 提供用户基本信息接口
- ✅ 支持 Refresh Token 刷新访问令牌

### 技术要求

- HTTP/HTTPS 协议
- JSON 数据格式
- 参数命名：**驼峰命名（camelCase）**

---

## 接入前准备

在开始对接 SSO 之前，您需要向敲鸭社区管理员申请以下信息：

### 必需参数清单

| 参数名 | 说明 | 示例 | 获取方式 |
|--------|------|------|---------|
| **Client ID** | 客户端唯一标识符 | `demo` | 向管理员申请 |
| **Client Secret** | 客户端密钥（需妥善保管） | `02d6e1cf7f20408db24...` | 向管理员申请 |
| **Redirect URI** | 授权回调地址（需预先注册） | `http://your-app.com/callback` | 向管理员提供并注册 |
| **SSO 服务器地址** | SSO 服务的基础 URL | `http://localhost:8520` | 管理员提供 |

### 申请流程

#### 第 1 步：准备应用信息

向管理员提供以下信息：

```
应用名称: 您的应用名称
应用描述: 简要说明应用用途
应用类型: Web 应用 / 移动应用 / 服务端应用
回调地址: http://your-app.com/callback (可提供多个)
所需权限: openid profile email (或其他需要的 scopes)
```

#### 第 2 步：获取凭证

管理员审核通过后，会提供给您：

```json
{
  "clientId": "your-client-id",
  "clientSecret": "your-client-secret-keep-it-safe",
  "redirectUris": [
    "http://your-app.com/callback",
    "http://localhost:3000/callback"  // 开发环境
  ],
  "scopes": ["openid", "profile", "email"]
}
```

#### 第 3 步：配置端点地址

根据管理员提供的 SSO 服务器地址，配置以下端点：

```javascript
const SSO_CONFIG = {
  baseUrl: 'http://localhost:8520',  // 替换为实际地址
  authorizeEndpoint: '/api/public/oauth2/authorize',
  tokenEndpoint: '/api/public/oauth2/token',
  userInfoEndpoint: '/api/user'
};
```

### ⚠️ 安全提醒

1. **妥善保管 Client Secret**
    - ❌ 不要将 Client Secret 硬编码在前端代码中
    - ✅ 应存储在后端服务器的环境变量或配置文件中
    - ✅ 生产环境使用专用的密钥管理服务

2. **回调地址验证**
    - SSO 服务器会严格验证 `redirectUri` 是否与注册的地址一致
    - 如需添加新的回调地址，请联系管理员重新配置

3. **使用 HTTPS**
    - 生产环境**必须**使用 HTTPS 协议
    - 开发环境可以使用 HTTP（localhost）

### 准备工作检查清单

在开始编码之前，请确认：

- [ ] 已获得 `clientId` 和 `clientSecret`
- [ ] 已在 SSO 服务器注册 `redirectUri`
- [ ] 已知晓 SSO 服务器地址
- [ ] 已了解所需的权限范围（scopes）
- [ ] 已配置好开发环境（支持 HTTPS 或 localhost）

---

## 授权流程

### 标准 OAuth 2.0 授权码流程（推荐使用 PKCE）

```
┌─────────────┐                                  ┌─────────────┐
│             │                                  │             │
│  第三方应用  │                                  │  SSO 服务器  │
│             │                                  │             │
└──────┬──────┘                                  └──────┬──────┘
       │                                                │
       │ 1. 跳转授权页面 (带 code_challenge)            │
       ├───────────────────────────────────────────────>│
       │                                                │
       │                                                │ 2. 用户登录并授权
       │                                                │
       │ 3. 返回授权码 (code)                           │
       │<───────────────────────────────────────────────┤
       │                                                │
       │ 4. 用授权码换取 Token (带 code_verifier)        │
       ├───────────────────────────────────────────────>│
       │                                                │
       │ 5. 返回 Access Token                           │
       │<───────────────────────────────────────────────┤
       │                                                │
       │ 6. 使用 Token 获取用户信息                      │
       ├───────────────────────────────────────────────>│
       │                                                │
       │ 7. 返回用户详细信息                            │
       │<───────────────────────────────────────────────┤
       │                                                │
```

### 流程步骤说明

1. **生成 PKCE 参数**（客户端）
    - 生成随机 `code_verifier`（128 字符）
    - 计算 `code_challenge = BASE64URL(SHA256(code_verifier))`
    - 生成随机 `state`（防 CSRF）

2. **跳转授权页面**
    - 构建授权 URL 并跳转到 SSO 授权端点

3. **用户授权**（SSO 服务器）
    - 用户在 SSO 页面登录
    - 用户同意授权

4. **获取授权码**
    - SSO 重定向回第三方应用，携带 `code` 和 `state`

5. **交换 Access Token**
    - 使用 `code` 和 `code_verifier` 换取 `accessToken`

6. **获取用户信息**
    - 使用 `accessToken` 调用用户信息接口

---

## 接口规范

### 基础信息

| 项目 | 说明 |
|------|------|
| **协议** | HTTP/HTTPS |
| **数据格式** | JSON |
| **字符编码** | UTF-8 |
| **参数命名** | 驼峰命名（camelCase） |
| **Base URL** | `http://localhost:8520` (生产环境请替换) |

### 端点列表

| 端点名称 | 方法 | 路径 |
|---------|------|------|
| 授权端点 | GET | `/api/public/oauth2/authorize` |
| 令牌端点 | POST | `/api/public/oauth2/token` |
| 用户信息端点 | GET | `/api/user` |
| 客户端信息端点 | GET | `/api/public/oauth2/clients/{clientId}` |

### 统一响应格式

所有接口返回统一的 `ApiResponse` 格式：

```json
{
  "code": 200,
  "message": "成功",
  "data": {
    // 实际数据
  }
}
```

---

## 接口详情

### 1. 授权端点

**用途**: 第三方应用跳转到此端点请求用户授权

#### 请求信息

```http
GET /api/public/oauth2/authorize?{params}
```

#### 请求参数（URL Query）

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `responseType` | String | ✅ | 固定值：`code` |
| `clientId` | String | ✅ | 客户端 ID（需向管理员申请） |
| `redirectUri` | String | ✅ | 授权回调地址（需预先注册） |
| `scope` | String | ❌ | 权限范围，空格分隔。如：`openid profile email` |
| `state` | String | ✅ | 随机字符串，用于防 CSRF 攻击 |
| `codeChallenge` | String | ✅ | PKCE code challenge（推荐） |
| `codeChallengeMethod` | String | ✅ | 固定值：`S256` |

#### 示例请求

```javascript
// 1. 生成 PKCE 参数
const codeVerifier = generateRandomString(128);
const codeChallenge = await sha256(codeVerifier);
const state = generateRandomString(32);

// 2. 保存到 sessionStorage
sessionStorage.setItem('code_verifier', codeVerifier);
sessionStorage.setItem('oauth_state', state);

// 3. 构建授权 URL
const params = new URLSearchParams({
    responseType: 'code',
    clientId: 'your-client-id',
    redirectUri: 'http://your-app.com/callback',
    scope: 'openid profile email',
    state: state,
    codeChallenge: codeChallenge,
    codeChallengeMethod: 'S256'
});

const authorizeUrl = `http://localhost:8520/api/public/oauth2/authorize?${params}`;

// 4. 跳转
window.location.href = authorizeUrl;
```

#### 响应说明

用户授权后，SSO 会重定向到 `redirectUri`，携带以下参数：

**成功响应**:
```
http://your-app.com/callback?code=AUTHORIZATION_CODE&state=YOUR_STATE
```

**失败响应**:
```
http://your-app.com/callback?error=access_denied&error_description=用户拒绝授权
```

---

### 2. 令牌端点

**用途**: 使用授权码换取 Access Token

#### 请求信息

```http
POST /api/public/oauth2/token
Content-Type: application/json
```

#### 请求参数（JSON Body）

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `grantType` | String | ✅ | 授权类型。授权码模式：`authorization_code`<br>刷新令牌模式：`refresh_token` |
| `clientId` | String | ✅ | 客户端 ID |
| `clientSecret` | String | ✅ | 客户端密钥 |
| `code` | String | ✅* | 授权码（授权码模式必填） |
| `redirectUri` | String | ✅* | 回调地址（授权码模式必填，需与授权时一致） |
| `codeVerifier` | String | ✅* | PKCE code verifier（授权码模式必填） |
| `refreshToken` | String | ✅* | 刷新令牌（刷新令牌模式必填） |

**\* 根据 `grantType` 不同，必填参数不同**

#### 示例请求（授权码模式）

```javascript
const tokenResponse = await fetch('http://localhost:8520/api/public/oauth2/token', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        grantType: 'authorization_code',
        clientId: 'your-client-id',
        clientSecret: 'your-client-secret',
        code: 'AUTHORIZATION_CODE',
        redirectUri: 'http://your-app.com/callback',
        codeVerifier: codeVerifier  // 从 sessionStorage 获取
    })
});

const response = await tokenResponse.json();
```

#### 响应示例

```json
{
  "code": 200,
  "message": "",
  "data": {
    "accessToken": "eyJhbGciOiJIUzM4NCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 86399,
    "refreshToken": "3I2JxEo7aBVVUYpXV3TX...",
    "scope": "openid profile email"
  }
}
```

#### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `accessToken` | String | 访问令牌，用于调用受保护的 API |
| `tokenType` | String | 令牌类型，固定为 `Bearer` |
| `expiresIn` | Integer | 访问令牌过期时间（秒） |
| `refreshToken` | String | 刷新令牌，用于获取新的访问令牌 |
| `scope` | String | 授权的权限范围 |

---

### 3. 用户信息端点

**用途**: 获取当前登录用户的详细信息

#### 请求信息

```http
GET /api/user
Authorization: Bearer {accessToken}
```

#### 请求头

| 参数名 | 值 | 说明 |
|--------|------|------|
| `Authorization` | `Bearer {accessToken}` | 必填，访问令牌 |

#### 示例请求

```javascript
const userInfoResponse = await fetch('http://localhost:8520/api/user', {
    headers: {
        'Authorization': `Bearer ${accessToken}`
    }
});

const response = await userInfoResponse.json();
```

#### 响应示例

```json
{
  "code": 200,
  "message": "",
  "data": {
    "id": "13",
    "name": "xhy",
    "email": "xhyovo@qq.com",
    "description": "社区管理员",
    "avatar": "589",
    "status": "ACTIVE",
    "role": "ADMIN",
    "tags": ["社区运营者"],
    "emailNotificationEnabled": true,
    "maxConcurrentDevices": 2,
    "currentSubscriptionPlanId": "e184abe9bb836471ffcd1c52e8d19bdf",
    "currentSubscriptionPlanName": "plus",
    "currentSubscriptionLevel": 2,
    "currentSubscriptionStartTime": "2025-09-28 23:12:07",
    "currentSubscriptionEndTime": "2026-09-28 23:12:07",
    "createTime": "2024-03-26 07:14:12",
    "updateTime": "2025-09-30 16:54:11"
  }
}
```

#### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | String | 用户唯一标识 |
| `name` | String | 用户名 |
| `email` | String | 邮箱地址 |
| `description` | String | 个人简介 |
| `avatar` | String | 头像 ID |
| `status` | String | 用户状态：`ACTIVE`(活跃)、`INACTIVE`(不活跃)、`SUSPENDED`(暂停)、`BANNED`(封禁) |
| `role` | String | 用户角色：`USER`(普通用户)、`ADMIN`(管理员)、`MODERATOR`(版主) |
| `tags` | Array | 用户标签列表 |
| `emailNotificationEnabled` | Boolean | 是否开启邮件通知 |
| `currentSubscriptionPlanName` | String | 当前订阅计划名称 |
| `currentSubscriptionLevel` | Integer | 订阅等级 |

---

### 4. 刷新令牌

当 `accessToken` 过期后，可使用 `refreshToken` 获取新的访问令牌。

#### 示例请求

```javascript
const tokenResponse = await fetch('http://localhost:8520/api/public/oauth2/token', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        grantType: 'refresh_token',
        clientId: 'your-client-id',
        clientSecret: 'your-client-secret',
        refreshToken: 'YOUR_REFRESH_TOKEN'
    })
});
```

---

## 代码示例

### 完整的前端集成示例（JavaScript）

```javascript
// OAuth2 配置
const CONFIG = {
    clientId: 'demo',
    clientSecret: 'your-client-secret',
    authorizeEndpoint: 'http://localhost:8520/api/public/oauth2/authorize',
    tokenEndpoint: 'http://localhost:8520/api/public/oauth2/token',
    userInfoEndpoint: 'http://localhost:8520/api/user',
    redirectUri: 'http://localhost:5174/oauth/callback',
    scope: 'openid profile email'
};

// ========== 工具函数 ==========

// 生成随机字符串
function generateRandomString(length) {
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
    let result = '';
    const randomValues = new Uint8Array(length);
    crypto.getRandomValues(randomValues);
    for (let i = 0; i < length; i++) {
        result += charset[randomValues[i] % charset.length];
    }
    return result;
}

// Base64 URL 编码
function base64UrlEncode(arrayBuffer) {
    const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

// 生成 PKCE code_challenge
async function generateCodeChallenge(codeVerifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(codeVerifier);
    const hash = await crypto.subtle.digest('SHA-256', data);
    return base64UrlEncode(hash);
}

// ========== 步骤 1: 发起授权请求 ==========

async function login() {
    // 生成 PKCE 参数
    const state = generateRandomString(32);
    const codeVerifier = generateRandomString(128);
    const codeChallenge = await generateCodeChallenge(codeVerifier);

    // 保存到 sessionStorage
    sessionStorage.setItem('oauth_state', state);
    sessionStorage.setItem('code_verifier', codeVerifier);

    // 构建授权 URL
    const params = new URLSearchParams({
        responseType: 'code',
        clientId: CONFIG.clientId,
        redirectUri: CONFIG.redirectUri,
        scope: CONFIG.scope,
        state: state,
        codeChallenge: codeChallenge,
        codeChallengeMethod: 'S256'
    });

    // 跳转到授权页面
    window.location.href = `${CONFIG.authorizeEndpoint}?${params}`;
}

// ========== 步骤 2: 处理授权回调 ==========

async function handleCallback() {
    // 解析 URL 参数
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const state = urlParams.get('state');

    // 验证 state
    const savedState = sessionStorage.getItem('oauth_state');
    if (state !== savedState) {
        throw new Error('State 验证失败');
    }

    // 获取 code_verifier
    const codeVerifier = sessionStorage.getItem('code_verifier');

    // 交换 Token
    const tokenResponse = await fetch(CONFIG.tokenEndpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            grantType: 'authorization_code',
            code: code,
            redirectUri: CONFIG.redirectUri,
            clientId: CONFIG.clientId,
            clientSecret: CONFIG.clientSecret,
            codeVerifier: codeVerifier
        })
    });

    const response = await tokenResponse.json();

    if (response.code !== 200) {
        throw new Error(response.message || '获取 Token 失败');
    }

    const tokenData = response.data;

    // 保存 Token
    sessionStorage.setItem('access_token', tokenData.accessToken);
    sessionStorage.setItem('refresh_token', tokenData.refreshToken);

    // 获取用户信息
    const userInfoResponse = await fetch(CONFIG.userInfoEndpoint, {
        headers: {
            'Authorization': `Bearer ${tokenData.accessToken}`
        }
    });

    const userInfoData = await userInfoResponse.json();
    const userInfo = userInfoData.code === 200 ? userInfoData.data : userInfoData;

    // 保存用户信息
    sessionStorage.setItem('user_info', JSON.stringify(userInfo));

    // 清理临时数据
    sessionStorage.removeItem('oauth_state');
    sessionStorage.removeItem('code_verifier');

    // 跳转到应用首页
    window.location.href = '/';
}
```

---

## 错误处理

### 错误响应格式

```json
{
  "code": 400,
  "message": "client_id不能为空",
  "data": null
}
```

### 常见错误码

| HTTP 状态码 | code | message | 说明 |
|------------|------|---------|------|
| 400 | 400 | `client_id不能为空` | 缺少必填参数 |
| 400 | 400 | `redirect_uri不能为空` | 缺少回调地址 |
| 400 | 400 | `无效的客户端` | Client ID 不存在 |
| 400 | 400 | `无效的重定向URI` | 回调地址未注册 |
| 400 | 400 | `授权码已过期` | 授权码超时（通常 5 分钟） |
| 400 | 400 | `无效的授权码` | 授权码不存在或已使用 |
| 401 | 401 | `未授权` | Token 无效或过期 |
| 403 | 403 | `用户拒绝授权` | 用户在授权页面点击拒绝 |

---

## 常见问题

### Q1: 如何申请 Client ID 和 Client Secret？

请参考文档开头的 [**接入前准备**](#接入前准备) 章节，其中详细说明了申请流程和所需信息。

简要步骤：
1. 准备应用信息（应用名称、描述、回调地址等）
2. 联系管理员（xhyovo@qq.com）提交申请
3. 获取 `clientId` 和 `clientSecret` 凭证
4. 配置端点地址并开始开发

### Q2: 为什么要使用 PKCE？

PKCE（Proof Key for Code Exchange）是 OAuth 2.0 的安全增强机制，可以防止授权码拦截攻击。对于前端应用（无法安全存储 Client Secret），强烈推荐使用 PKCE。

### Q3: accessToken 的有效期是多久？

默认 24 小时（86400 秒）。过期后可使用 `refreshToken` 获取新的 `accessToken`。

### Q4: 参数命名为什么使用驼峰？

本系统后端使用 Java + Spring Boot 开发，默认使用驼峰命名规范。所有请求参数和响应字段均使用驼峰命名（如 `clientId`、`accessToken`）。

### Q5: 如何在生产环境使用？

将文档中的 `http://localhost:8520` 替换为生产环境的实际域名，并确保：
- 使用 HTTPS 协议
- 正确配置 CORS（如果前端与后端域名不同）
- 妥善保管 Client Secret（建议在后端服务器中使用）

### Q6: 支持哪些权限范围（Scopes）？

当前支持的标准 Scopes：
- `openid` - 必填，表示使用 OpenID Connect
- `profile` - 获取用户基本信息（用户名、简介等）
- `email` - 获取用户邮箱

### Q7: Token 存储在哪里？

推荐存储方式：
- 前端应用：`sessionStorage`（关闭浏览器后自动清除）
- 移动应用：安全的本地存储（如 iOS Keychain、Android Keystore）
- 后端应用：服务器内存或安全的缓存系统

---

## 技术支持

如有问题，请联系：
- 📧 Email: xhyovo@qq.com
- 🐛 Issue: [GitHub Issues](https://github.com/your-repo/issues)

---

## 更新日志

### v1.0.0 (2025-01-21)
- ✅ 初始版本发布
- ✅ 支持 OAuth 2.0 授权码模式
- ✅ 支持 PKCE 安全增强
- ✅ 提供用户信息接口
- ✅ 支持 Refresh Token

---

**文档版本**: v1.0.0
**最后更新**: 2025-01-21
