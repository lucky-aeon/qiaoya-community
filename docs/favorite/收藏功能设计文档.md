# 敲鸭社区收藏（Favorite）功能设计文档

作者：后端
最后更新：2025-10-20
状态：设计稿（可落地）
适用范围：收藏（文章/章节/评论/题目）统一模型与接口

> 术语澄清：本文中的“收藏”指用户将内容加入个人收藏列表，便于回访与管理；与“关注（Follow）”不同，收藏不订阅内容更新通知。

## 1. 功能概述

### 1.1 业务背景
为提升社区的回访率与内容留存，支持用户对多种内容（文章、章节、评论、题目）进行收藏；提供我的收藏列表与收藏状态/数量查询，便于前端渲染收藏按钮与个人中心管理。

### 1.2 核心能力
- 多类型收藏：支持 POST（文章）/ CHAPTER（章节）/ COMMENT（评论）/ INTERVIEW_QUESTION（题目）
- 状态查询：单个与批量收藏状态查询
- 数量统计：目标被收藏数量统计（单个/批量）
- 我的收藏：按类型分页查询，按时间倒序
- 并发与幂等：插入唯一约束与显式并发处理

## 2. 架构与分层（DDD）

遵循项目分层规范：Application → Domain Service → Repository；Assembler 负责实体与 DTO 转换。

```
interfaces/
└── favorite/
    ├── controller/
    │   └── FavoriteController.java           # 用户收藏API（路由：/api/favorites）
    └── request/
        ├── ToggleFavoriteRequest.java        # 切换收藏请求（targetId, targetType）
        └── BatchFavoriteRequest.java         # 批量状态/计数请求

application/
└── favorite/
    ├── service/
    │   ├── FavoriteAppService.java           # 收藏应用服务
    │   └── AdminFavoriteAppService.java      # 管理员收藏服务（/api/admin/favorites）
    ├── dto/
    │   ├── FavoriteDTO.java                  # 收藏记录DTO
    │   ├── FavoriteStatusDTO.java            # 收藏状态（是否收藏/计数）
    │   └── FavoriteListItemDTO.java          # 我的收藏列表（含扩展信息）
    └── assembler/
        └── FavoriteAssembler.java            # 转换器（静态方法）

domain/
└── favorite/
    ├── entity/
    │   └── FavoriteEntity.java               # 收藏实体
    ├── valueobject/
    │   └── FavoriteTargetType.java           # 收藏目标类型（枚举）
    ├── repository/
    │   └── FavoriteRepository.java           # BaseMapper 接口
    └── service/
        └── FavoriteDomainService.java        # 领域服务

infrastructure/
└── converter/
    └── FavoriteTargetTypeConverter.java      # MyBatis 枚举转换器
```

## 3. 领域模型设计

### 3.1 实体与枚举

```java
// 位置：org.xhy.community.domain.favorite.entity.FavoriteEntity
@TableName("favorites")
public class FavoriteEntity {
    @TableId(type = IdType.ASSIGN_UUID)
    private String id;

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;

    /** 收藏用户ID */
    private String userId;

    /** 目标对象ID */
    private String targetId;

    /** 目标类型：POST/CHAPTER/COMMENT/INTERVIEW_QUESTION */
    @TableField(typeHandler = FavoriteTargetTypeConverter.class)
    private FavoriteTargetType targetType;
}
```

```java
// 位置：org.xhy.community.domain.favorite.valueobject.FavoriteTargetType
public enum FavoriteTargetType {
    POST("文章"),
    CHAPTER("章节"),
    COMMENT("评论"),
    INTERVIEW_QUESTION("题目");

    private final String description;
    FavoriteTargetType(String description) { this.description = description; }
    public String getDescription() { return description; }
    public static FavoriteTargetType fromCode(String code) {
        for (FavoriteTargetType t : values()) if (t.name().equals(code)) return t;
        throw new IllegalArgumentException("Unknown favorite target type: " + code);
    }
}
```

说明：与点赞 Like 模块的 `LikeTargetType` 一致采用英文枚举名，数据库使用字符串存储，依赖 `FavoriteTargetTypeConverter` 进行转换，并在 `MyBatisTypeHandlerConfig` 中注册。

### 3.2 领域服务职责

```java
// 位置：org.xhy.community.domain.favorite.service.FavoriteDomainService
@Service
public class FavoriteDomainService {
    private final FavoriteRepository favoriteRepository;

    public FavoriteDomainService(FavoriteRepository favoriteRepository) { this.favoriteRepository = favoriteRepository; }

    /**
     * 切换收藏（未收藏 -> 插入；已收藏 -> 删除）。返回是否“收藏后”的状态。
     * 与点赞一致采用“物理写入/删除”，保证唯一约束简单有效。
     */
    public boolean toggleFavorite(String userId, String targetId, FavoriteTargetType targetType) {
        LambdaQueryWrapper<FavoriteEntity> qw = new LambdaQueryWrapper<>()
            .eq(FavoriteEntity::getUserId, userId)
            .eq(FavoriteEntity::getTargetId, targetId)
            .eq(FavoriteEntity::getTargetType, targetType)
            .last("LIMIT 1");
        FavoriteEntity existing = favoriteRepository.selectOne(qw);
        if (existing == null) {
            try {
                FavoriteEntity e = new FavoriteEntity();
                e.setUserId(userId); e.setTargetId(targetId); e.setTargetType(targetType);
                favoriteRepository.insert(e);
                return true;
            } catch (DataIntegrityViolationException ex) {
                // 并发下唯一约束冲突：视为已收藏
                throw new BusinessException(FavoriteErrorCode.ALREADY_FAVORITED);
            }
        } else {
            favoriteRepository.delete(qw);
            return false;
        }
    }

    public boolean isFavorited(String userId, String targetId, FavoriteTargetType targetType) { /* exists 查询 */ }
    public Map<String, Boolean> batchCheckFavoriteStatus(String userId, Map<String, FavoriteTargetType> targets) { /* 批量 exists */ }
    public long countFavorites(String targetId, FavoriteTargetType targetType) { /* count 查询 */ }
    public Map<String, Long> batchCountFavorites(Map<String, FavoriteTargetType> targets) { /* 分组统计 */ }
    public IPage<FavoriteEntity> pageMyFavorites(String userId, FavoriteTargetType type, int pageNum, int pageSize) { /* 分页 */ }
}
```

备注：
- 查询默认忽略软删除（全局配置已处理），因此无需显式 `.eq(deleted, false)` 条件。
- 若未来需要保留收藏历史，可切换为“软删除 + 部分唯一索引（where deleted_at is null）”，见 4.1 说明。

## 4. 数据库设计（PostgreSQL / Flyway）

### 4.1 表结构与索引

采用“物理删除”简化唯一约束：

```sql
-- 迁移文件：src/main/resources/db/migration/VXX__Create_favorites_table.sql
CREATE TABLE favorites (
  id           VARCHAR(36) PRIMARY KEY,
  user_id      VARCHAR(36) NOT NULL,
  target_type  VARCHAR(40) NOT NULL, -- POST/CHAPTER/COMMENT/INTERVIEW_QUESTION
  target_id    VARCHAR(36) NOT NULL,
  create_time  TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  update_time  TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at   TIMESTAMP            -- 预留软删除
);

-- 唯一约束（物理删除足够）：防止重复收藏
CREATE UNIQUE INDEX uk_favorites_unique ON favorites (user_id, target_type, target_id);

-- 查询优化：按目标统计/查列表
CREATE INDEX idx_favorites_target ON favorites (target_type, target_id);
CREATE INDEX idx_favorites_user   ON favorites (user_id, create_time DESC);

COMMENT ON TABLE favorites IS '收藏表，支持文章/章节/评论/题目';
COMMENT ON COLUMN favorites.target_type IS '目标类型：POST/CHAPTER/COMMENT/INTERVIEW_QUESTION';
```

软删除替代方案（如需保留历史）：使用部分唯一索引，仅约束未删除行。

```sql
-- 仅当切换为软删除模型时使用：
CREATE UNIQUE INDEX uk_favorites_unique_alive
  ON favorites (user_id, target_type, target_id)
  WHERE deleted_at IS NULL;
```

### 4.2 数据量与增长
- 收藏记录与活跃用户规模同比，读多写少
- 针对列表分页：`user_id + create_time desc` 覆盖索引
- 针对计数与状态：`target_type + target_id` 索引

## 5. 应用层设计（AppService/DTO/Assembler）

### 5.1 应用服务（仅编排）

```java
@Service
public class FavoriteAppService {
    private final FavoriteDomainService favoriteDomainService;

    public FavoriteAppService(FavoriteDomainService favoriteDomainService) { this.favoriteDomainService = favoriteDomainService; }

    @Transactional
    public boolean toggleFavorite(String targetId, FavoriteTargetType targetType, String currentUserId) {
        return favoriteDomainService.toggleFavorite(currentUserId, targetId, targetType);
    }

    public FavoriteStatusDTO getFavoriteStatus(String targetId, FavoriteTargetType targetType, String currentUserId) {
        boolean isFav = favoriteDomainService.isFavorited(currentUserId, targetId, targetType);
        long count = favoriteDomainService.countFavorites(targetId, targetType);
        return new FavoriteStatusDTO(targetId, targetType, isFav, count);
    }

    public Map<String, Boolean> batchGetFavoriteStatus(Map<String, FavoriteTargetType> targets, String currentUserId) {
        return favoriteDomainService.batchCheckFavoriteStatus(currentUserId, targets);
    }

    public IPage<FavoriteListItemDTO> pageMyFavorites(FavoriteTargetType type, int pageNum, int pageSize, String currentUserId) {
        IPage<FavoriteEntity> page = favoriteDomainService.pageMyFavorites(currentUserId, type, pageNum, pageSize);
        // 组装扩展信息，见 6.2 关联数据查询
        return FavoriteAssembler.toListItemPage(page, /* 扩展信息映射 */);
    }
}
```

### 5.2 DTO 与 Assembler（静态方法）

```java
public class FavoriteDTO { /* id, userId, targetId, targetType, createTime */ }
public class FavoriteStatusDTO { /* targetId, targetType, isFavorited, favoritesCount */ }
public class FavoriteListItemDTO { /* targetId, targetType, title/author/snippet 等扩展 */ }

public class FavoriteAssembler {
    public static FavoriteDTO toDTO(FavoriteEntity e) { /* BeanUtils.copyProperties */ }
    public static List<FavoriteDTO> toDTOList(List<FavoriteEntity> list) { /* stream map */ }
    public static IPage<FavoriteListItemDTO> toListItemPage(IPage<FavoriteEntity> page, Map<String, Object> ext) { /* 组装 */ }
}
```

## 6. API 设计与关联数据

### 6.1 路由与请求（用户接口）

```http
# 切换收藏
POST /api/favorites/toggle
Body: { "targetId": "post-123", "targetType": "POST" }
Resp: { "isFavorited": true }

# 收藏状态（含计数）
GET /api/favorites/status/{targetType}/{targetId}
Resp: { "targetId":"post-123", "targetType":"POST", "isFavorited":true, "favoritesCount": 23 }

# 批量收藏状态
POST /api/favorites/status/batch
Body: { "targets": [ {"targetId":"p1","targetType":"POST"}, {"targetId":"c1","targetType":"COMMENT"} ] }
Resp: { "POST:p1": true, "COMMENT:c1": false }

# 我的收藏（按时间倒序）
GET /api/favorites/my?targetType=POST&pageNum=1&pageSize=20
```

请求对象：

```java
public class ToggleFavoriteRequest { @NotBlank String targetId; @NotNull FavoriteTargetType targetType; }
public class BatchFavoriteRequest { @NotEmpty List<Item> targets; static class Item { String targetId; FavoriteTargetType targetType; } }
```

说明：
- API 层（Controller）负责参数格式校验（@Valid/@NotBlank/@NotNull），并获取 `currentUserId`（UserContext 仅限 Controller 使用）。
- App 层传入 Domain 层的多参数建议汇聚为实体或值对象，DTO 仅用于对外输出。

### 6.2 关联数据查询（避免 N+1）

我的收藏列表需要展示标题/作者/摘要等扩展信息，采用批量查询：

```java
// 按类型收集 ID
Set<String> postIds = items.stream().filter(t -> t.type == POST).map(FavoriteEntity::getTargetId).collect(toSet());
Set<String> chapterIds = ...; Set<String> commentIds = ...; Set<String> questionIds = ...;

// 批量查询基础信息，拼装 Map
Map<String, PostEntity> postMap = postDomainService.getByIds(postIds);
Map<String, ChapterEntity> chapterMap = chapterDomainService.getByIds(chapterIds);
Map<String, CommentEntity> commentMap = commentDomainService.getByIds(commentIds);
Map<String, InterviewQuestionEntity> questionMap = interviewQuestionDomainService.getByIds(questionIds);

// Assembler 中一次性组装 DTO 列表，避免循环查询
```

## 7. 权限与边界

- 用户接口仅允许访问“当前用户”的收藏数据；管理员接口提供全量查询与统计。
- 领域复用：若同一查询既供用户又供管理员使用，按 AccessLevel 枚举控制范围（参考权限控制规范）。
- 请求与 DTO 中涉及类型传递必须使用枚举类型，不可用字符串代替。

## 8. 性能与缓存

### 8.1 缓存键设计（可选）

```text
favorite:check:{userId}:{targetType}:{targetId} -> bool           # 用户是否收藏
favorite:count:{targetType}:{targetId}          -> long           # 目标收藏数
favorite:list:{userId}:{targetType}             -> ZSET(targetId, ts) # 我的收藏（可做前置页缓存）
```

刷新策略：
- toggle 成功后，删除/更新相关键；
- 批量查询优先走 DB，热点对象可回写缓存；
- 计数可采用延迟双删或异步校准，防止写放大。

### 8.2 数据库优化
- 分页使用覆盖索引（user_id, create_time desc）
- 计数/状态查询使用（target_type, target_id）索引
- 热门目标可做本地热点缓存（Caffeine）

## 9. 可观测性与风控

- 埋点：toggle 成功/失败、批量状态查询耗时、我的收藏分页耗时与命中率
- 指标：QPS、错误码分布、DB/缓存命中、慢查询比例
- 风控：阈值与限流，防止异常批量操作；活动日志记录（可发 `FavoriteToggledEvent` 给 Activity 模块）

## 10. 迁移与回滚

- 新建 Flyway 脚本：`VXX__Create_favorites_table.sql`
- 应用启动对 `MyBatisTypeHandlerConfig` 增加注册：`FavoriteTargetTypeConverter`
- 回滚：删除相关 API 与表（若有数据保留需求，先导出归档）

## 11. 与项目规范对齐要点（Checklist）

- 命名：实体以 `Entity` 结尾，服务以 `AppService`/`DomainService` 结尾，仓储以 `Repository` 结尾
- 分层：Application 仅编排；Domain 调仓储；不在 Domain 做参数格式校验
- Assembler：位于 application/favorite/assembler，使用 `BeanUtils.copyProperties`
- 分页：`request` 对象继承 `interfaces/common/request/PageRequest`
- 类型：所有类型字段（targetType）必须使用枚举；新增枚举记得注册 TypeHandler
- 软删除：查询忽略软删除已由配置处理；本方案默认采取物理删除，必要时切换为软删除 + 部分唯一索引

## 12. 后续迭代（里程碑）

1. M1：落地核心能力（toggle/status/count/my-list）与迁移脚本
2. M2：列表关联数据组装规范化（通用装配器与批量接口）
3. M3：缓存与热点优化、批量接口压测与容错
4. M4：管理员统计面板（按类型分布、日趋势）

---

附：`MyBatisTypeHandlerConfig` 注册示例（增量）

```java
// infrastructure/config/MyBatisTypeHandlerConfig.java
typeHandlerRegistry.register(FavoriteTargetType.class, new FavoriteTargetTypeConverter());
```

