# 用户活动日志系统扩展设计文档

作者：后端
最后更新：2025-09-27
状态：设计稿（可落地）
适用范围：认证/业务活动扩展日志、AOP 记录、异步处理

维护人：后端
关键代码路径：
- AOP 注解与切面：src/main/java/org/xhy/community/application/aspect/*
- 领域服务/实体/仓储：src/main/java/org/xhy/community/domain/useractivity/*
- 管理端接口：src/main/java/org/xhy/community/interfaces/admin/useractivity/*

## 1. 概述

基于项目中已有的用户活动日志系统，进行功能扩展以支持更丰富的用户行为追踪。现有系统专门记录用户认证相关活动（登录、注册等），本方案在保持现有架构的基础上，扩展支持业务操作追踪（如查看文章、发表文章等）。

## 1.1 现有系统分析

**已有完整实现：**
- 数据库表：`user_activity_logs`（V15迁移脚本）
- 完整DDD架构：Domain、Application、Infrastructure、Interface层
- AOP切面：`UserActivityLogAspect` + `@LogUserActivity`注解
- 异步处理：专用线程池`userActivityLogExecutor`
- 管理员查询接口：`AdminUserActivityLogController`

**现有活动类型：**
- 认证相关：LOGIN_SUCCESS、LOGIN_FAILED、REGISTER_SUCCESS、REGISTER_FAILED
- 账户管理：LOGOUT、CHANGE_PASSWORD、RESET_PASSWORD

**扩展目标：**
在现有基础上增加业务操作追踪，如内容浏览、创作、互动等行为。

## 2. 活动类型扩展设计

### 2.1 现有ActivityType枚举分析

**当前类型（7种）：**
```java
public enum ActivityType {
    LOGIN_SUCCESS("登录成功"),
    LOGIN_FAILED("登录失败"),
    REGISTER_SUCCESS("注册成功"),
    REGISTER_FAILED("注册失败"),
    LOGOUT("用户登出"),
    CHANGE_PASSWORD("修改密码"),
    RESET_PASSWORD("重置密码");
}
```

### 2.2 扩展后的ActivityType设计

**扩展原则：**
- 保持现有类型不变，确保向后兼容
- 按业务领域分组新增类型
- 使用语义化命名，便于理解和维护

**扩展后的完整枚举：**
```java
public enum ActivityType {
    // ==================== 认证相关（现有） ====================
    LOGIN_SUCCESS("登录成功"),
    LOGIN_FAILED("登录失败"),
    REGISTER_SUCCESS("注册成功"),
    REGISTER_FAILED("注册失败"),
    LOGOUT("用户登出"),
    CHANGE_PASSWORD("修改密码"),
    RESET_PASSWORD("重置密码"),
    
    // ==================== 内容浏览 ====================
    VIEW_POST("查看文章"),
    VIEW_COURSE("查看课程"),
    VIEW_USER_PROFILE("查看用户资料"),
    SEARCH_CONTENT("搜索内容"),
    
    // ==================== 内容创作 ====================
    CREATE_POST("发表文章"),
    UPDATE_POST("编辑文章"),
    DELETE_POST("删除文章"),
    CREATE_COURSE("创建课程"),
    UPDATE_COURSE("编辑课程"),
    DELETE_COURSE("删除课程"),
    
    // ==================== 社交互动 ====================
    LIKE_POST("点赞文章"),
    UNLIKE_POST("取消点赞文章"),
    COMMENT_POST("评论文章"),
    DELETE_COMMENT("删除评论"),
    FOLLOW_USER("关注用户"),
    UNFOLLOW_USER("取消关注用户"),
    SHARE_POST("分享文章"),
    
    // ==================== 学习行为 ====================
    ENROLL_COURSE("注册课程"),
    COMPLETE_CHAPTER("完成章节"),
    START_LEARNING("开始学习"),
    
    // ==================== 管理操作 ====================
    ADMIN_LOGIN("管理员登录"),
    ADMIN_UPDATE_USER("管理员更新用户"),
    ADMIN_DELETE_POST("管理员删除文章"),
    ADMIN_UPDATE_COURSE("管理员更新课程");
    
    private final String description;
    
    ActivityType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * 获取活动类型的分类
     */
    public ActivityCategory getCategory() {
        switch (this) {
            case LOGIN_SUCCESS:
            case LOGIN_FAILED:
            case REGISTER_SUCCESS:
            case REGISTER_FAILED:
            case LOGOUT:
            case CHANGE_PASSWORD:
            case RESET_PASSWORD:
                return ActivityCategory.AUTHENTICATION;
                
            case VIEW_POST:
            case VIEW_COURSE:
            case VIEW_USER_PROFILE:
            case SEARCH_CONTENT:
                return ActivityCategory.BROWSING;
                
            case CREATE_POST:
            case UPDATE_POST:
            case DELETE_POST:
            case CREATE_COURSE:
            case UPDATE_COURSE:
            case DELETE_COURSE:
                return ActivityCategory.CONTENT_CREATION;
                
            case LIKE_POST:
            case UNLIKE_POST:
            case COMMENT_POST:
            case DELETE_COMMENT:
            case FOLLOW_USER:
            case UNFOLLOW_USER:
            case SHARE_POST:
                return ActivityCategory.SOCIAL_INTERACTION;
                
            case ENROLL_COURSE:
            case COMPLETE_CHAPTER:
            case START_LEARNING:
                return ActivityCategory.LEARNING;
                
            case ADMIN_LOGIN:
            case ADMIN_UPDATE_USER:
            case ADMIN_DELETE_POST:
            case ADMIN_UPDATE_COURSE:
                return ActivityCategory.ADMINISTRATION;
                
            default:
                return ActivityCategory.OTHER;
        }
    }
}

/**
 * 活动分类枚举
 */
public enum ActivityCategory {
    AUTHENTICATION("认证相关"),
    BROWSING("内容浏览"),
    CONTENT_CREATION("内容创作"),
    SOCIAL_INTERACTION("社交互动"),
    LEARNING("学习行为"),
    ADMINISTRATION("管理操作"),
    OTHER("其他");
    
    private final String description;
    
    ActivityCategory(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

## 3. 数据库表结构扩展设计

### 3.1 现有表结构分析

**当前表字段（V15迁移脚本）：**
```sql
CREATE TABLE user_activity_logs (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),              -- 关联用户ID，登录失败时可能为NULL
    email VARCHAR(255) NOT NULL,      -- 用户邮箱
    activity_type VARCHAR(50) NOT NULL, -- 活动类型
    browser VARCHAR(500),             -- 浏览器信息
    equipment VARCHAR(100),           -- 设备信息
    ip VARCHAR(45) NOT NULL,          -- IP地址
    user_agent TEXT,                  -- 完整的User-Agent信息
    failure_reason VARCHAR(500),      -- 失败原因，成功时为NULL
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted BOOLEAN NOT NULL DEFAULT FALSE
);
```

### 3.2 扩展方案设计

**方案一：原地扩展（推荐）**
在现有表基础上添加新字段，保持向后兼容：

```sql
-- V16__Extend_user_activity_logs_table.sql
-- 为支持更丰富的业务操作，扩展用户活动日志表

-- 添加业务相关字段
ALTER TABLE user_activity_logs 
ADD COLUMN target_type VARCHAR(50),          -- 目标类型：POST、COURSE、USER等
ADD COLUMN target_id VARCHAR(36),            -- 目标对象ID
ADD COLUMN request_method VARCHAR(10),       -- HTTP请求方法
ADD COLUMN request_path VARCHAR(500),        -- 请求路径
ADD COLUMN execution_time_ms INTEGER,        -- 执行时间（毫秒）
ADD COLUMN session_id VARCHAR(64),           -- 会话ID
ADD COLUMN context_data JSONB;               -- 扩展上下文数据（JSON格式）

-- 为新字段添加索引
CREATE INDEX idx_user_activity_logs_target ON user_activity_logs(target_type, target_id);
CREATE INDEX idx_user_activity_logs_session ON user_activity_logs(session_id);
CREATE INDEX idx_user_activity_logs_request_path ON user_activity_logs(request_path);

-- 添加字段注释
COMMENT ON COLUMN user_activity_logs.target_type IS '目标类型：POST、COURSE、USER等';
COMMENT ON COLUMN user_activity_logs.target_id IS '目标对象ID';
COMMENT ON COLUMN user_activity_logs.request_method IS 'HTTP请求方法：GET、POST等';
COMMENT ON COLUMN user_activity_logs.request_path IS '请求路径';
COMMENT ON COLUMN user_activity_logs.execution_time_ms IS '接口执行时间（毫秒）';
COMMENT ON COLUMN user_activity_logs.session_id IS '用户会话ID';
COMMENT ON COLUMN user_activity_logs.context_data IS '扩展上下文数据，JSON格式存储';
```

**方案二：分表设计（备选）**
如果业务差异过大，可考虑分表：

```sql
-- 认证活动日志表（现有表保持不变）
user_activity_logs

-- 业务活动日志表（新表）
CREATE TABLE business_activity_logs (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type VARCHAR(50) NOT NULL,
    target_type VARCHAR(50),
    target_id VARCHAR(36),
    request_method VARCHAR(10),
    request_path VARCHAR(500),
    execution_time_ms INTEGER,
    ip VARCHAR(45),
    user_agent TEXT,
    session_id VARCHAR(64),
    context_data JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted BOOLEAN NOT NULL DEFAULT FALSE
);
```

**推荐使用方案一**，原因：
- 保持系统架构统一
- 减少代码重复
- 便于统一查询和分析
- 现有字段对业务操作仍有意义

### 3.3 扩展后的字段说明

| 字段名 | 类型 | 说明 | 示例值 |
|--------|------|------|--------|
| **现有字段** |
| id | VARCHAR(36) | 主键ID | uuid |
| user_id | VARCHAR(36) | 用户ID | uuid |
| email | VARCHAR(255) | 用户邮箱 | user@example.com |
| activity_type | VARCHAR(50) | 活动类型 | VIEW_POST |
| browser | VARCHAR(500) | 浏览器信息 | Chrome 120.0 |
| equipment | VARCHAR(100) | 设备信息 | Desktop |
| ip | VARCHAR(45) | IP地址 | 192.168.1.1 |
| user_agent | TEXT | User-Agent | Mozilla/5.0... |
| failure_reason | VARCHAR(500) | 失败原因 | 文章不存在 |
| **新增字段** |
| target_type | VARCHAR(50) | 目标类型 | POST、COURSE、USER |
| target_id | VARCHAR(36) | 目标ID | 文章ID、课程ID等 |
| request_method | VARCHAR(10) | HTTP方法 | GET、POST、PUT |
| request_path | VARCHAR(500) | 请求路径 | /api/posts/123 |
| execution_time_ms | INTEGER | 执行时间 | 150 |
| session_id | VARCHAR(64) | 会话ID | session_abc123 |
| context_data | JSONB | 扩展数据 | {"category": "tech"} |

### 3.4 字段使用策略

**认证操作（现有逻辑保持不变）：**
- 主要使用：user_id、email、activity_type、ip、user_agent、failure_reason
- 新字段：target_type=null、target_id=null

**业务操作（新增逻辑）：**
- 必填字段：user_id、activity_type、ip、request_method、request_path
- 可选字段：target_type、target_id、execution_time_ms、context_data
- 未使用字段：email可为空、failure_reason仅在失败时使用

**字段复用策略：**
- `browser`、`equipment`：所有操作通用
- `failure_reason`：任何操作失败时都可使用
- `user_agent`：所有HTTP请求通用
## 4. AOP注解扩展设计

### 4.1 现有注解分析

**现有@LogUserActivity注解：**
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogUserActivity {
    ActivityType successType();     // 成功时的活动类型
    ActivityType failureType();     // 失败时的活动类型
    boolean logSuccess() default true;
    boolean logFailure() default true;
}
```

**使用场景：** 专门用于认证操作，如登录、注册等

### 4.2 扩展方案设计

**方案一：新增@ActivityLog注解（推荐）**
为业务操作创建新的注解，与现有认证注解并存。采用极简设计，通过URL自动解析目标信息：

```java
/**
 * 业务活动日志注解
 * 用于记录用户的业务操作行为，如查看文章、发表内容等
 * 采用极简设计，自动从URL解析目标类型和ID
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ActivityLog {
    
    /**
     * 活动类型（必填）
     */
    ActivityType value();
    
    /**
     * 是否异步处理，默认true
     */
    boolean async() default true;
    
    /**
     * 是否记录请求体，默认true
     */
    boolean recordRequest() default true;
}
```

**方案二：扩展现有注解（备选）**
扩展@LogUserActivity注解支持更多参数：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogUserActivity {
    // 现有字段保持不变
    ActivityType successType();
    ActivityType failureType() default ActivityType.LOGIN_FAILED;
    boolean logSuccess() default true;
    boolean logFailure() default true;
    
    // 新增字段（兼容业务操作）
    String targetType() default "";
    String targetIdParam() default "";
    boolean recordContext() default false;
    boolean recordExecutionTime() default false;
}
```

**推荐使用方案一**，原因：
- 职责分离清晰：认证操作 vs 业务操作
- 减少认证注解的复杂性
- 便于独立维护和优化
- 更好的语义表达
- **极简设计**：只需指定活动类型，其他信息自动推断

### 4.3 URL自动解析逻辑设计

为了实现极简的注解使用体验，设计URL自动解析机制，从请求路径中自动提取目标类型和ID：

```java
/**
 * URL模式解析器
 * 自动从请求路径中解析目标类型和目标ID
 */
public class UrlPatternParser {
    
    // URL模式映射配置
    private static final Map<Pattern, TargetTypeMapping> URL_PATTERNS = Map.of(
        // 文章相关
        Pattern.compile("/api/posts/(\\w+)"), new TargetTypeMapping("POST", 1),
        Pattern.compile("/api/admin/posts/(\\w+)"), new TargetTypeMapping("POST", 1),
        
        // 课程相关
        Pattern.compile("/api/courses/(\\w+)"), new TargetTypeMapping("COURSE", 1),
        Pattern.compile("/api/admin/courses/(\\w+)"), new TargetTypeMapping("COURSE", 1),
        
        // 用户相关
        Pattern.compile("/api/users/(\\w+)"), new TargetTypeMapping("USER", 1),
        Pattern.compile("/api/admin/users/(\\w+)"), new TargetTypeMapping("USER", 1),
        
        // 章节相关
        Pattern.compile("/api/courses/(\\w+)/chapters/(\\w+)"), new TargetTypeMapping("CHAPTER", 2)
    );
    
    /**
     * 从URL路径解析目标信息
     */
    public static TargetInfo parseFromUrl(String requestPath) {
        for (Map.Entry<Pattern, TargetTypeMapping> entry : URL_PATTERNS.entrySet()) {
            Matcher matcher = entry.getKey().matcher(requestPath);
            if (matcher.matches()) {
                TargetTypeMapping mapping = entry.getValue();
                String targetId = matcher.group(mapping.getIdGroupIndex());
                return new TargetInfo(mapping.getTargetType(), targetId);
            }
        }
        
        // 如果无法解析，返回null（如POST /api/posts创建操作）
        return null;
    }
}

/**
 * 目标类型映射
 */
@Data
@AllArgsConstructor
public static class TargetTypeMapping {
    private String targetType;
    private int idGroupIndex;  // 正则表达式中ID所在的组索引
}

/**
 * 解析结果
 */
@Data
@AllArgsConstructor
public static class TargetInfo {
    private String type;
    private String id;
}
```

**解析示例：**
- `/api/posts/abc123` → targetType="POST", targetId="abc123"
- `/api/courses/def456` → targetType="COURSE", targetId="def456"  
- `/api/admin/users/ghi789` → targetType="USER", targetId="ghi789"
- `/api/posts` (POST请求) → targetType=null, targetId=null（创建操作）

### 4.4 AOP切面扩展设计

**新增BusinessActivityLogAspect：**
```java
/**
 * 业务活动日志切面
 * 处理@ActivityLog注解，自动解析URL并记录用户的业务操作行为
 */
@Aspect
@Component
@Order(2) // 在UserActivityLogAspect之后执行
public class BusinessActivityLogAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(BusinessActivityLogAspect.class);
    private final UserActivityLogDomainService userActivityLogDomainService;
    
    @Around("@annotation(activityLog)")
    public Object logBusinessActivity(ProceedingJoinPoint joinPoint, ActivityLog activityLog) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        // 获取HTTP请求信息
        HttpServletRequest request = getCurrentRequest();
        String requestPath = request.getRequestURI();
        
        // 自动解析目标信息
        TargetInfo targetInfo = UrlPatternParser.parseFromUrl(requestPath);
        
        // 构建活动上下文
        ActivityContext context = ActivityContext.builder()
            .userId(getCurrentUserId())
            .activityType(activityLog.value())
            .targetType(targetInfo != null ? targetInfo.getType() : null)
            .targetId(targetInfo != null ? targetInfo.getId() : null)
            .requestMethod(request.getMethod())
            .requestPath(requestPath)
            .requestBody(activityLog.recordRequest() ? getRequestBody(joinPoint) : null)
            .ipAddress(getClientIp(request))
            .userAgent(request.getHeader("User-Agent"))
            .sessionId(request.getSession().getId())
            .build();
        
        try {
            // 执行目标方法
            Object result = joinPoint.proceed();
            
            // 记录成功日志
            if (activityLog.async()) {
                recordActivityAsync(context, startTime, null);
            } else {
                recordActivity(context, startTime, null);
            }
            
            return result;
            
        } catch (Exception e) {
            // 记录失败日志
            if (activityLog.async()) {
                recordActivityAsync(context, startTime, e.getMessage());
            } else {
                recordActivity(context, startTime, e.getMessage());
            }
            
            throw e;
        }
    }
    
    /**
     * 获取当前HTTP请求
     */
    private HttpServletRequest getCurrentRequest() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes instanceof ServletRequestAttributes) {
            return ((ServletRequestAttributes) requestAttributes).getRequest();
        }
        throw new IllegalStateException("No HTTP request found");
    }
    
    /**
     * 获取当前用户ID
     */
    private String getCurrentUserId() {
        // 从SecurityContext或其他地方获取当前用户ID
        // 具体实现依赖于项目的认证方式
        return "current_user_id"; // 占位符
    }
    
    /**
     * 获取请求体内容
     */
    private String getRequestBody(ProceedingJoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        if (args != null && args.length > 0) {
            // 简化处理：将第一个@RequestBody参数转为JSON
            for (Object arg : args) {
                if (arg != null && isRequestBodyObject(arg)) {
                    try {
                        return JSON.toJSONString(arg);
                    } catch (Exception e) {
                        logger.warn("Failed to serialize request body: {}", e.getMessage());
                        return "Failed to serialize";
                    }
                }
            }
        }
        return null;
    }
    
    /**
     * 判断是否为请求体对象
     */
    private boolean isRequestBodyObject(Object obj) {
        String className = obj.getClass().getSimpleName();
        return className.endsWith("Request") || className.endsWith("DTO");
    }
    
    /**
     * 获取客户端IP地址
     */
    private String getClientIp(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Real-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
    
    /**
     * 异步记录活动日志
     */
    @Async("businessActivityExecutor")
    protected void recordActivityAsync(ActivityContext context, long startTime, String errorMessage) {
        recordActivity(context, startTime, errorMessage);
    }
    
    /**
     * 记录活动日志
     */
    private void recordActivity(ActivityContext context, long startTime, String errorMessage) {
        try {
            int executionTime = (int) (System.currentTimeMillis() - startTime);
            
            userActivityLogDomainService.recordBusinessActivity(
                context.getUserId(),
                context.getActivityType(),
                context.getTargetType(),
                context.getTargetId(),
                context.getRequestMethod(),
                context.getRequestPath(),
                executionTime,
                context.getIpAddress(),
                context.getUserAgent(),
                context.getSessionId(),
                context.getRequestBody(),
                errorMessage
            );
            
            logger.debug("Successfully recorded business activity: userId={}, type={}, target={}:{}", 
                        context.getUserId(), context.getActivityType(), 
                        context.getTargetType(), context.getTargetId());
                        
        } catch (Exception e) {
            // 日志记录失败不应该影响主业务
            logger.error("Failed to record business activity: {}", context, e);
        }
    }
}
```

### 4.5 使用示例设计

**认证操作（使用现有@LogUserActivity）：**
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @PostMapping("/login")
    @LogUserActivity(
        successType = ActivityType.LOGIN_SUCCESS,
        failureType = ActivityType.LOGIN_FAILED
    )
    public ApiResponse<LoginResponseDTO> login(@RequestBody LoginRequest request) {
        // 登录逻辑
    }
}
```

**业务操作（使用新@ActivityLog - 极简版）：**
```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    
    @GetMapping("/{postId}")
    @ActivityLog(ActivityType.VIEW_POST)  // 极简！自动解析 targetType="POST", targetId=postId
    public ApiResponse<PostDTO> getPostById(@PathVariable String postId) {
        return ApiResponse.success(postAppService.getPostById(postId));
    }
    
    @PostMapping
    @ActivityLog(ActivityType.CREATE_POST)  // 创建操作，无目标ID
    public ApiResponse<PostDTO> createPost(@RequestBody CreatePostRequest request) {
        return ApiResponse.success(postAppService.createPost(request));
    }
    
    @PutMapping("/{postId}")
    @ActivityLog(ActivityType.UPDATE_POST)  // 自动解析 targetType="POST", targetId=postId
    public ApiResponse<PostDTO> updatePost(@PathVariable String postId, 
                                         @RequestBody UpdatePostRequest request) {
        return ApiResponse.success(postAppService.updatePost(postId, request));
    }
    
    @DeleteMapping("/{postId}")
    @ActivityLog(ActivityType.DELETE_POST)
    public ApiResponse<Void> deletePost(@PathVariable String postId) {
        postAppService.deletePost(postId);
        return ApiResponse.success();
    }
    
    @PostMapping("/{postId}/like")
    @ActivityLog(ActivityType.LIKE_POST)  // 自动解析目标为文章
    public ApiResponse<Void> likePost(@PathVariable String postId) {
        postAppService.likePost(postId);
        return ApiResponse.success();
    }
}

@RestController
@RequestMapping("/api/courses")
public class CourseController {
    
    @GetMapping("/{courseId}")
    @ActivityLog(ActivityType.VIEW_COURSE)  // 自动解析 targetType="COURSE", targetId=courseId
    public ApiResponse<CourseDTO> getCourseById(@PathVariable String courseId) {
        return ApiResponse.success(courseAppService.getCourseById(courseId));
    }
    
    @PostMapping("/{courseId}/enroll")
    @ActivityLog(ActivityType.ENROLL_COURSE)  // 注册课程
    public ApiResponse<Void> enrollCourse(@PathVariable String courseId) {
        courseAppService.enrollCourse(courseId);
        return ApiResponse.success();
    }
    
    @GetMapping("/{courseId}/chapters/{chapterId}")
    @ActivityLog(ActivityType.VIEW_CHAPTER)  // 自动解析 targetType="CHAPTER", targetId=chapterId
    public ApiResponse<ChapterDTO> getChapter(@PathVariable String courseId,
                                            @PathVariable String chapterId) {
        return ApiResponse.success(chapterAppService.getChapter(chapterId));
    }
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{userId}")
    @ActivityLog(ActivityType.VIEW_USER_PROFILE)  // 查看用户资料
    public ApiResponse<UserDTO> getUserProfile(@PathVariable String userId) {
        return ApiResponse.success(userAppService.getUserProfile(userId));
    }
    
    @PostMapping("/{userId}/follow")
    @ActivityLog(ActivityType.FOLLOW_USER)  // 关注用户
    public ApiResponse<Void> followUser(@PathVariable String userId) {
        userAppService.followUser(userId);
        return ApiResponse.success();
    }
}

@RestController
@RequestMapping("/api/admin")
public class AdminController {
    
    @DeleteMapping("/posts/{postId}")
    @ActivityLog(ActivityType.ADMIN_DELETE_POST)  // 管理员删除文章
    public ApiResponse<Void> deletePost(@PathVariable String postId) {
        adminPostAppService.deletePost(postId);
        return ApiResponse.success();
    }
    
    @PutMapping("/users/{userId}/status")
    @ActivityLog(ActivityType.ADMIN_UPDATE_USER)  // 管理员更新用户状态
    public ApiResponse<Void> updateUserStatus(@PathVariable String userId,
                                            @RequestBody UpdateUserStatusRequest request) {
        adminUserAppService.updateUserStatus(userId, request);
        return ApiResponse.success();
    }
}
```

**高级用法（可选参数）：**
```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    
    @PostMapping
    @ActivityLog(
        value = ActivityType.CREATE_POST,
        recordRequest = false,  // 不记录请求体（如果包含敏感信息）
        async = false          // 同步处理（如果需要确保立即记录）
    )
    public ApiResponse<PostDTO> createSensitivePost(@RequestBody CreatePostRequest request) {
        return ApiResponse.success(postAppService.createPost(request));
    }
}
```

### 4.6 配置和优化

**异步配置扩展：**
```java
@Configuration
@EnableAsync
public class ActivityLogAsyncConfig {
    
    // 现有认证日志线程池
    @Bean("userActivityLogExecutor")
    public TaskExecutor userActivityLogExecutor() {
        // 现有配置
    }
    
    // 新增业务日志线程池
    @Bean("businessActivityExecutor")
    public TaskExecutor businessActivityExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(15);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("business-activity-");
        executor.setKeepAliveSeconds(60);
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

**Domain服务扩展：**
```java
@Service
public class UserActivityLogDomainService {
    
    // 现有认证日志记录方法
    public void recordActivity(String userId, String email, ActivityType activityType, 
                              String browser, String equipment, String ip, 
                              String userAgent, String failureReason) {
        // 现有实现保持不变
    }
    
    // 新增业务日志记录方法
    public void recordBusinessActivity(String userId, ActivityType activityType,
                                     String targetType, String targetId,
                                     String requestMethod, String requestPath,
                                     Integer executionTimeMs, String ipAddress,
                                     String userAgent, String sessionId,
                                     Map<String, Object> contextData, String errorMessage) {
        
        UserActivityLogEntity entity = new UserActivityLogEntity();
        entity.setUserId(userId);
        entity.setActivityType(activityType);
        entity.setTargetType(targetType);
        entity.setTargetId(targetId);
        entity.setRequestMethod(requestMethod);
        entity.setRequestPath(requestPath);
        entity.setExecutionTimeMs(executionTimeMs);
        entity.setIp(ipAddress);
        entity.setUserAgent(userAgent);
        entity.setSessionId(sessionId);
        entity.setContextData(contextData != null ? JSON.toJSONString(contextData) : null);
        entity.setFailureReason(errorMessage);
        // 其他字段设为null或默认值
        
        userActivityLogRepository.insert(entity);
    }
}
```

## 5. 实体扩展设计

### 5.1 UserActivityLogEntity扩展

**需要添加的字段：**
```java
@TableName("user_activity_logs")
public class UserActivityLogEntity {
    // 现有字段保持不变...
    
    // 新增字段
    @TableField("target_type")
    private String targetType;
    
    @TableField("target_id")
    private String targetId;
    
    @TableField("request_method")
    private String requestMethod;
    
    @TableField("request_path")
    private String requestPath;
    
    @TableField("execution_time_ms")
    private Integer executionTimeMs;
    
    @TableField("session_id")
    private String sessionId;
    
    @TableField("context_data")
    private String contextData;  // JSON字符串
    
    // getter/setter方法...
}
```

## 6. 实施计划

### 6.1 分阶段实施

**第一阶段：扩展基础架构（1周）**
1. 扩展ActivityType枚举，添加业务操作类型
2. 执行数据库表结构扩展（V16迁移脚本）
3. 扩展UserActivityLogEntity实体类
4. 扩展UserActivityLogDomainService服务方法

**第二阶段：新增AOP注解（1周）**
1. 创建@ActivityLog注解
2. 实现BusinessActivityLogAspect切面
3. 配置新的异步线程池
4. 完善上下文信息提取逻辑

**第三阶段：业务集成（1-2周）**
1. 在核心接口添加@ActivityLog注解
2. 优先级：查看文章 → 发表文章 → 课程相关 → 社交功能
3. 测试验证和性能调优
4. 监控和告警配置

### 6.2 向后兼容保证

**现有功能不受影响：**
- 现有@LogUserActivity注解和UserActivityLogAspect保持不变
- 认证相关日志记录逻辑完全不变
- 新增字段都设置为可空，不影响现有数据

**渐进式迁移：**
- 新功能使用@ActivityLog注解
- 现有认证功能继续使用@LogUserActivity
- 长期可考虑统一到@ActivityLog（可选）

### 6.3 性能优化建议

**异步处理优化：**
- 使用独立线程池避免相互影响
- 批量写入机制提升数据库性能
- 合理的队列大小和拒绝策略

**存储优化：**
- 定期清理90天以上的详细日志
- 生成统计数据用于长期分析
- 考虑冷热数据分离

**监控指标：**
- 日志写入TPS和延迟
- 异步队列积压情况
- 数据库性能指标

## 7. 总结

### 7.1 扩展方案优势

**1. 保持架构一致性**
- 复用现有DDD架构和AOP基础设施
- 避免重复开发，降低维护成本
- 统一的日志查询和分析能力

**2. 向后兼容性强**
- 现有认证日志功能完全不受影响
- 渐进式扩展，风险可控
- 新老系统和谐共存

**3. 扩展性好**
- 支持任意业务操作类型
- 灵活的上下文数据记录
- 便于后续数据分析和挖掘

**4. 性能影响小**
- 异步处理不影响主业务
- 合理的线程池配置
- 可选的功能开关

### 7.2 关键设计特点

**双注解并行：**
- @LogUserActivity：专门用于认证操作
- @ActivityLog：用于业务操作
- 职责分离，便于维护

**表结构复用：**
- 在现有表基础上扩展字段
- 字段复用最大化
- 保持数据一致性

**渐进式实施：**
- 分阶段实施降低风险
- 核心功能优先
- 持续优化改进

### 7.3 预期收益

**业务价值：**
- 全面的用户行为洞察
- 数据驱动的产品优化
- 精准的用户画像分析

**技术价值：**
- 统一的日志记录框架
- 高性能的异步处理
- 完善的监控和告警

**运营价值：**
- 热门内容识别
- 用户活跃度分析
- 功能使用情况统计

## 8. 极简设计优势

### 8.1 开发效率显著提升

**注解参数大幅简化：**
- **旧设计**：5个参数（value、description、targetType、targetIdParam、recordContext等）
- **新设计**：1个必填参数（value），2个可选参数（async、recordRequest）
- **效率提升**：减少80%的配置工作量

**使用对比：**
```java
// 旧版本（复杂）
@ActivityLog(
    value = ActivityType.VIEW_POST,
    description = "查看文章详情", 
    targetType = "POST",
    targetIdParam = "postId",
    recordContext = true,
    recordExecutionTime = true
)

// 新版本（极简）
@ActivityLog(ActivityType.VIEW_POST)
```

### 8.2 维护成本降低

**自动化程度高：**
- URL解析规则集中管理，一处配置多处生效
- 新增路由时只需更新解析规则，无需修改每个注解
- 减少人为错误（如targetType拼写错误）

**统一性保证：**
- 相同资源类型的接口自动使用相同的targetType
- 避免不同开发者使用不同的命名约定
- 自动记录标准化的请求信息

### 8.3 学习成本大幅降低

**使用门槛极低：**
- 新开发者只需了解ActivityType枚举
- 无需理解复杂的参数配置
- 注解使用方式符合直觉

**推广容易：**
- 简单的用法更容易在团队中推广
- 减少培训成本和上手时间
- 提高开发团队的接受度

### 8.4 功能完整性保持

**信息记录完整：**
- 自动记录所有关键信息（用户、时间、URL、参数等）
- 支持目标对象的自动识别和关联
- 保持与复杂版本相同的功能水平

**灵活性依然存在：**
- 通过可选参数支持特殊需求
- URL解析规则支持复杂的路径模式
- 可以根据需要扩展解析逻辑

### 8.5 扩展性和可维护性

**规则配置化：**
- URL解析规则可以外部化配置
- 支持正则表达式的复杂匹配
- 可以动态调整解析策略

**架构清晰：**
- 职责分离：注解负责标识，解析器负责提取信息
- 模块化设计：各组件独立可测试
- 易于扩展新的资源类型和路径模式

### 8.6 性能影响最小

**解析开销可控：**
- URL解析仅在有@ActivityLog注解的方法中触发
- 正则匹配性能良好，缓存机制可进一步优化
- 异步处理确保不影响主业务

**内存使用优化：**
- 编译时确定的解析规则，运行时内存占用小
- 减少注解参数减少了内存开销
- 智能的请求体记录避免不必要的序列化

通过这套扩展方案，既保持了现有系统的稳定性，又为平台提供了强大的用户行为分析能力，为业务决策和产品优化提供有力支撑。
│   └── service/
│       └── UserActivityLogDomainService.java -- 领域服务
├── application/user/
│   ├── service/
│   │   └── UserActivityLogAppService.java   -- 应用服务
│   ├── dto/
│   │   └── UserActivityLogDTO.java          -- DTO对象
│   └── assembler/
│       └── UserActivityLogAssembler.java    -- 转换器
└── infrastructure/
    ├── aop/
    │   ├── ActivityLog.java                 -- 自定义注解
    │   └── ActivityLogAspect.java           -- AOP切面
    ├── event/
    │   ├── ActivityLogEvent.java            -- 事件类
    │   ├── ActivityLogEventPublisher.java   -- 事件发布器
    │   └── ActivityLogEventListener.java    -- 事件监听器
    └── config/
        └── ActivityLogAsyncConfig.java      -- 异步配置
```

## 4. 核心功能设计

### 4.1 活动类型枚举
```java
public enum ActivityType {
    // 内容相关
    VIEW_POST("查看文章"),
    CREATE_POST("发表文章"), 
    UPDATE_POST("编辑文章"),
    DELETE_POST("删除文章"),
    
    // 课程相关
    VIEW_COURSE("查看课程"),
    CREATE_COURSE("创建课程"),
    UPDATE_COURSE("更新课程"),
    ENROLL_COURSE("注册课程"),
    
    // 用户相关
    LOGIN("登录"),
    LOGOUT("登出"),
    REGISTER("注册"),
    UPDATE_PROFILE("更新资料"),
    
    // 互动相关
    LIKE_POST("点赞文章"),
    UNLIKE_POST("取消点赞"),
    COMMENT_POST("评论文章"),
    FOLLOW_USER("关注用户"),
    UNFOLLOW_USER("取消关注"),
    
    // 管理相关
    ADMIN_LOGIN("管理员登录"),
    ADMIN_UPDATE_USER("管理员更新用户"),
    ADMIN_DELETE_POST("管理员删除文章");
    
    private final String description;
    
    ActivityType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

### 4.2 自定义注解设计
```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ActivityLog {
    /**
     * 活动类型
     */
    ActivityType value();
    
    /**
     * 活动描述
     */
    String description() default "";
    
    /**
     * 是否记录请求参数
     */
    boolean recordRequest() default true;
    
    /**
     * 是否记录响应数据
     */
    boolean recordResponse() default false;
    
    /**
     * 是否异步处理
     */
    boolean async() default true;
    
    /**
     * 目标类型（用于业务分类）
     */
    String targetType() default "";
}
```

### 4.3 实体设计规范
```java
@TableName("user_activity_logs")
public class UserActivityLogEntity extends BaseEntity {
    /**
     * 用户ID
     */
    private String userId;
    
    /**
     * 活动类型
     */
    private ActivityType activityType;
    
    /**
     * HTTP请求方法
     */
    private String requestMethod;
    
    /**
     * 请求路径
     */
    private String requestPath;
    
    /**
     * 请求体内容（JSON格式）
     */
    private String requestBody;
    
    /**
     * 响应数据摘要
     */
    private String responseData;
    
    /**
     * 客户端IP地址
     */
    private String ipAddress;
    
    /**
     * 用户代理字符串
     */
    private String userAgent;
    
    /**
     * 平台信息（web/mobile/app）
     */
    private String platform;
    
    /**
     * 执行时间（毫秒）
     */
    private Integer executionTimeMs;
    
    /**
     * 执行状态（SUCCESS/FAILED）
     */
    private String status;
    
    /**
     * 错误信息（失败时记录）
     */
    private String errorMessage;
    
    /**
     * 会话ID
     */
    private String sessionId;
    
    // getters and setters...
}
```

### 4.4 AOP切面逻辑流程
1. **方法执行前：** 
   - 记录开始时间
   - 获取HttpServletRequest信息
   - 提取用户ID和会话ID
   - 构建基础上下文信息

2. **方法执行中：** 
   - 正常执行业务逻辑
   - 捕获可能的异常信息

3. **方法执行后：** 
   - 计算执行时间
   - 判断成功/失败状态
   - 构建ActivityLogEvent对象

4. **异步发布：** 
   - 发布活动日志事件
   - 交给异步处理器处理

### 4.5 事件驱动机制设计
```java
// 事件类设计
public class ActivityLogEvent {
    private String userId;
    private String sessionId;
    private ActivityType activityType;
    private String requestMethod;
    private String requestPath;
    private String requestBody;
    private String responseData;
    private String ipAddress;
    private String userAgent;
    private String platform;
    private Integer executionTimeMs;
    private String status;
    private String errorMessage;
    private Long timestamp;
    private String traceId;  // 链路追踪ID
    
    // 构造函数、getters、setters、builder模式...
}
```

## 5. 性能优化设计

### 5.1 异步处理配置
```java
@Configuration
@EnableAsync
public class ActivityLogAsyncConfig {
    
    @Bean("activityLogExecutor")
    public TaskExecutor activityLogExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);           // 核心线程数
        executor.setMaxPoolSize(10);           // 最大线程数
        executor.setQueueCapacity(500);        // 队列容量
        executor.setThreadNamePrefix("activity-log-");
        executor.setKeepAliveSeconds(60);      // 线程空闲时间
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略
        );
        executor.initialize();
        return executor;
    }
}
```

### 5.2 批量写入优化策略
- **缓存机制：** 内存缓冲区收集日志（ArrayList + synchronized）
- **批量大小：** 每100条记录批量写入数据库
- **定时刷新：** 每5秒强制刷新缓冲区，避免数据丢失
- **并发安全：** 使用线程安全的集合类或synchronized关键字
- **事务处理：** 批量插入使用单个事务，提升性能

### 5.3 数据库优化方案
**索引策略：**
- 主键索引：id（BIGSERIAL自动创建）
- 复合索引：(user_id, created_at) 用户查询优化
- 单列索引：activity_type 活动类型过滤
- 单列索引：status 状态过滤
- 单列索引：session_id 会话查询

**分区表设计：**
```sql
-- 按月分区（PostgreSQL 10+）
CREATE TABLE user_activity_logs (
    -- 字段定义...
) PARTITION BY RANGE (created_at);

-- 创建分区表
CREATE TABLE user_activity_logs_2024_01 PARTITION OF user_activity_logs
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE user_activity_logs_2024_02 PARTITION OF user_activity_logs
FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

**连接池优化：**
- 读写分离：写操作使用主库，查询使用从库
- 连接池大小：根据业务量调整HikariCP配置
- 超时设置：合理设置连接超时和查询超时

### 5.4 内存优化
- **对象复用：** 使用对象池减少GC压力
- **序列化优化：** 合理控制requestBody和responseData大小
- **缓存策略：** 热点数据使用Redis缓存
- **内存监控：** 监控堆内存使用情况

## 6. 监控和维护

### 6.1 健康检查指标
```java
@Component
public class ActivityLogHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            // 检查异步队列状态
            int queueSize = getAsyncQueueSize();
            
            // 检查数据库连接
            boolean dbConnected = checkDatabaseConnection();
            
            // 检查处理速率
            double processingRate = getProcessingRate();
            
            if (queueSize > 1000 || !dbConnected || processingRate < 10) {
                return Health.down()
                        .withDetail("queueSize", queueSize)
                        .withDetail("dbConnected", dbConnected)
                        .withDetail("processingRate", processingRate)
                        .build();
            }
            
            return Health.up()
                    .withDetail("queueSize", queueSize)
                    .withDetail("processingRate", processingRate)
                    .build();
                    
        } catch (Exception e) {
            return Health.down().withException(e).build();
        }
    }
}
```

### 6.2 关键监控指标
**性能指标：**
- 日志写入TPS（每秒事务数）
- 平均响应时间
- 异步队列长度
- 线程池活跃线程数
- 数据库连接池使用率

**业务指标：**
- 各活动类型的频率统计
- 用户活跃度分布
- 热门功能使用排行
- 错误率和异常统计

**系统指标：**
- JVM堆内存使用率
- GC频率和耗时
- 数据库表空间使用率
- 磁盘IO和网络IO

### 6.3 告警机制设计
**告警规则：**
- 队列积压：连续5分钟队列长度超过500触发告警
- 处理延迟：平均处理时间超过1秒触发告警
- 写入失败：5分钟内失败率超过5%触发告警
- 磁盘空间：数据库磁盘使用率超过80%触发告警

**告警通知：**
- 紧急告警：短信 + 邮件 + 钉钉群通知
- 一般告警：邮件 + 钉钉群通知
- 告警恢复：自动发送恢复通知

### 6.4 数据治理策略
**数据清理政策：**
```java
@Component
public class ActivityLogDataRetentionPolicy {
    
    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void cleanupOldLogs() {
        try {
            // 删除90天前的详细日志
            LocalDateTime cutoffTime = LocalDateTime.now().minusDays(90);
            int deletedCount = userActivityLogRepository.deleteByCreateTimeBefore(cutoffTime);
            
            log.info("Deleted {} old activity logs before {}", deletedCount, cutoffTime);
            
            // 生成统计数据（保留更长时间）
            generateDailyStatistics(cutoffTime.toLocalDate());
            
        } catch (Exception e) {
            log.error("Failed to cleanup old activity logs", e);
        }
    }
    
    private void generateDailyStatistics(LocalDate date) {
        // 生成每日统计数据，如用户活跃度、功能使用量等
        // 保存到单独的统计表中，保留时间可以更长（如1年）
    }
}
```

**数据归档方案：**
- 热数据：最近30天，保留在主表中
- 温数据：30-90天，可考虑压缩存储
- 冷数据：90天以上，归档到对象存储（如OSS）
- 统计数据：聚合后长期保留（1年以上）

## 7. 使用场景和示例

### 7.1 业务埋点使用示例
```java
// 文章相关操作
@RestController
@RequestMapping("/api/posts")
public class PostController {
    
    @GetMapping("/{postId}")
    @ActivityLog(value = ActivityType.VIEW_POST, description = "查看文章详情")
    public Result<PostDTO> getPostById(@PathVariable String postId) {
        // 业务逻辑，会自动记录用户查看文章的行为
        return Result.success(postAppService.getPostById(postId));
    }
    
    @PostMapping
    @ActivityLog(
        value = ActivityType.CREATE_POST, 
        description = "发表文章",
        recordRequest = true,    // 记录文章内容
        recordResponse = true    // 记录返回的文章ID
    )
    public Result<PostDTO> createPost(@RequestBody CreatePostRequest request) {
        // 业务逻辑，会自动记录用户发表文章的行为
        return Result.success(postAppService.createPost(request));
    }
    
    @PutMapping("/{postId}")
    @ActivityLog(ActivityType.UPDATE_POST)
    public Result<PostDTO> updatePost(@PathVariable String postId, 
                                    @RequestBody UpdatePostRequest request) {
        return Result.success(postAppService.updatePost(postId, request));
    }
}

// 用户相关操作
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping("/login")
    @ActivityLog(
        value = ActivityType.LOGIN, 
        description = "用户登录",
        recordRequest = false,   // 不记录密码等敏感信息
        recordResponse = false
    )
    public Result<UserDTO> login(@RequestBody LoginRequest request) {
        return Result.success(userAppService.login(request));
    }
    
    @PostMapping("/{userId}/follow")
    @ActivityLog(ActivityType.FOLLOW_USER)
    public Result<Void> followUser(@PathVariable String userId) {
        userAppService.followUser(userId);
        return Result.success();
    }
}
```

### 7.2 管理员后台使用示例
```java
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    
    @PutMapping("/users/{userId}/status")
    @ActivityLog(
        value = ActivityType.ADMIN_UPDATE_USER,
        description = "管理员修改用户状态",
        recordRequest = true,
        recordResponse = true
    )
    public Result<Void> updateUserStatus(@PathVariable String userId,
                                       @RequestBody UpdateUserStatusRequest request) {
        adminUserAppService.updateUserStatus(userId, request);
        return Result.success();
    }
    
    @DeleteMapping("/posts/{postId}")
    @ActivityLog(ActivityType.ADMIN_DELETE_POST)
    public Result<Void> deletePost(@PathVariable String postId) {
        adminPostAppService.deletePost(postId);
        return Result.success();
    }
}
```

### 7.3 数据分析查询示例
```java
@Service
public class UserActivityLogAppService {
    
    /**
     * 获取用户活动日志
     */
    public IPage<UserActivityLogDTO> getUserActivityLogs(String userId, 
                                                        ActivityType activityType,
                                                        LocalDateTime startTime,
                                                        LocalDateTime endTime,
                                                        Integer pageNum, 
                                                        Integer pageSize) {
        
        IPage<UserActivityLogEntity> page = userActivityLogDomainService
            .getUserActivityLogs(userId, activityType, startTime, endTime, pageNum, pageSize);
            
        return page.convert(UserActivityLogAssembler::toDTO);
    }
    
    /**
     * 获取用户活动统计
     */
    public UserActivityStatsDTO getUserActivityStats(String userId, Integer days) {
        // 统计用户近N天的活动数据
        LocalDateTime startTime = LocalDateTime.now().minusDays(days);
        
        // 按活动类型分组统计
        Map<ActivityType, Long> activityCounts = userActivityLogDomainService
            .getActivityCountsByType(userId, startTime);
            
        // 统计总活动次数
        long totalActivities = activityCounts.values().stream()
            .mapToLong(Long::longValue).sum();
            
        // 统计活跃天数
        int activeDays = userActivityLogDomainService
            .getActiveDaysCount(userId, startTime);
            
        return UserActivityStatsDTO.builder()
            .totalActivities(totalActivities)
            .activeDays(activeDays)
            .activityCounts(activityCounts)
            .build();
    }
    
    /**
     * 获取热门内容统计
     */
    public List<PopularContentDTO> getPopularContent(ActivityType activityType, 
                                                   Integer days, 
                                                   Integer limit) {
        // 统计最受欢迎的文章、课程等
        LocalDateTime startTime = LocalDateTime.now().minusDays(days);
        
        return userActivityLogDomainService
            .getPopularTargets(activityType, startTime, limit)
            .stream()
            .map(this::buildPopularContentDTO)
            .collect(Collectors.toList());
    }
}
```

## 8. 扩展性设计

### 8.1 活动类型扩展机制
**枚举扩展：**
- 新增活动类型时，只需在ActivityType枚举中添加新值
- 数据库使用VARCHAR存储，天然支持新类型
- 历史数据不受影响，保持向后兼容

**分类体系：**
```java
public enum ActivityCategory {
    READ("阅读类"),
    WRITE("创建类"),
    INTERACT("互动类"),
    SYSTEM("系统类"),
    ADMIN("管理类");
    
    private final String description;
}

// 在ActivityType中关联分类
public enum ActivityType {
    VIEW_POST("查看文章", ActivityCategory.READ),
    CREATE_POST("发表文章", ActivityCategory.WRITE),
    LIKE_POST("点赞文章", ActivityCategory.INTERACT);
    
    private final String description;
    private final ActivityCategory category;
}
```

### 8.2 存储后端扩展
**多存储支持：**
- 接口抽象：定义ActivityLogStorage接口
- 实现类：DatabaseStorage、ElasticsearchStorage、ClickHouseStorage
- 配置选择：通过配置文件选择存储后端

**数据分流策略：**
- 实时数据：写入PostgreSQL，支持CRUD操作
- 分析数据：同步到ClickHouse，支持大数据分析
- 搜索数据：同步到Elasticsearch，支持全文搜索

### 8.3 分析能力扩展
**实时流计算：**
- Kafka：作为数据管道，接收活动日志
- Flink：实时计算用户行为指标
- Redis：缓存实时计算结果

**机器学习集成：**
- 用户画像：基于行为数据生成用户标签
- 推荐算法：分析用户偏好，推荐相关内容
- 异常检测：识别异常用户行为模式

**BI工具集成：**
- Grafana：实时监控大屏
- Tableau：深度数据分析
- 自定义报表：业务定制化报表

### 8.4 微服务架构适配
**服务拆分：**
- activity-log-service：专门的日志服务
- analytics-service：数据分析服务
- notification-service：告警通知服务

**API网关集成：**
- 在网关层统一记录请求日志
- 支持跨服务的链路追踪
- 统一的用户身份识别

## 9. 实施建议

### 9.1 分阶段实施计划

**第一阶段：基础框架（1-2周）**
- 数据库表创建和基础CRUD
- Domain层和Application层基础代码
- 简单的同步日志记录

**第二阶段：AOP和异步（1周）**
- 实现自定义注解和AOP切面
- 集成事件驱动和异步处理
- 配置线程池和异步优化

**第三阶段：性能优化（1周）**
- 批量写入优化
- 数据库索引和分区优化
- 监控指标和健康检查

**第四阶段：数据分析（1-2周）**
- 实现统计分析功能
- 数据可视化和报表
- 业务价值挖掘

### 9.2 风险控制措施

**降级机制：**
```java
@Service
public class ActivityLogFallbackService {
    
    private final AtomicBoolean enableLogging = new AtomicBoolean(true);
    
    public void disableLogging() {
        enableLogging.set(false);
        log.warn("Activity logging has been disabled due to system issues");
    }
    
    public void enableLogging() {
        enableLogging.set(true);
        log.info("Activity logging has been enabled");
    }
    
    public boolean isLoggingEnabled() {
        return enableLogging.get();
    }
}
```

**容量规划：**
- 按照日活跃用户数 × 平均操作数 × 1.5倍安全系数规划
- 定期评估存储增长趋势，提前扩容
- 监控数据库连接数和TPS，避免达到瓶颈

**回滚策略：**
- 所有数据库变更使用FlyWay管理，支持版本回滚
- 功能开关：通过配置文件快速关闭日志记录
- 数据备份：定期备份重要的统计数据

### 9.3 团队协作建议

**开发规范：**
1. 注解使用规范：明确哪些接口需要添加@ActivityLog
2. 敏感数据处理：不记录密码、token等敏感信息
3. 性能考虑：避免记录过大的requestBody和responseData
4. 异常处理：确保日志记录失败不影响主业务

**代码审查重点：**
- 检查是否正确使用@ActivityLog注解
- 确认异步处理配置正确
- 验证敏感数据脱敏处理
- 检查异常处理逻辑

**文档维护：**
- 及时更新ActivityType枚举说明
- 维护数据分析SQL脚本库
- 记录性能优化措施和效果
- 定期更新运维手册

## 10. 总结

用户活动日志系统采用AOP + 异步处理架构，具有以下特点：

**核心优势：**
1. **低侵入性：** 通过注解方式，对业务代码几乎无侵入
2. **高性能：** 异步处理不影响主业务响应时间
3. **扩展性强：** 支持多种活动类型和存储后端
4. **监控完善：** 全方位的监控指标和告警机制

**业务价值：**
1. **用户洞察：** 深度分析用户行为，优化产品体验
2. **运营支撑：** 提供数据驱动的运营决策支持
3. **安全审计：** 满足合规要求，支持问题追溯
4. **性能监控：** 实时监控系统性能和异常

**技术特色：**
1. **DDD架构：** 符合项目架构规范，职责分离清晰
2. **事件驱动：** 解耦业务逻辑和日志记录
3. **批量优化：** 支持批量写入，提升数据库性能
4. **多维度监控：** 业务、性能、系统三个维度全覆盖

这套方案既满足了当前的用户行为追踪需求，又为未来的数据分析和业务洞察奠定了坚实的基础。通过合理的架构设计和性能优化，确保系统在高并发场景下的稳定运行。
