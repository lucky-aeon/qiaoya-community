# 聊天室功能技术方案（DDD + MyBatis Plus）

## 一、背景与目标
- 目标：为敲鸭社区新增“聊天室”能力，实现“按套餐隔离的房间”和“消息的引用/艾特（@）”。
- 范围：本阶段落地领域与数据结构、应用与领域服务接口、权限与套餐隔离策略、迁移脚本设计与通知扩展点；Controller 与前端交互可后续迭代。
- 约束：遵循项目 DDD 分层规范与 MyBatis Plus 使用规范；UUID 主键、软删除时间戳、Flyway 管理迁移、无自定义 SQL、Assembler 静态方法、构造器注入、UserContext 仅允许在 Controller 使用。

## 二、整体架构与调用关系
- 子域：`chat`
- Application → Domain → Repository（仅此）；任何层可访问 Infrastructure；Infrastructure 仅能回调 Application。
- Application 层：流程编排、DTO 转换、事务；不做参数格式校验（由 API 层完成）。
- Domain 层：核心业务与规则校验（成员校验、引用合法性、套餐隔离）；使用 MP 条件构造器进行持久化操作。

## 三、领域模型设计
### 3.1 实体（Entity）
- `ChatRoomEntity`（房间）
  - 字段：`id`, `name`, `description?`, `subscriptionPlanId`, `creatorId`, `createTime`, `updateTime`, `deletedAt`
  - 规则：
    - 房间强关联套餐 `subscriptionPlanId`；用于隔离不同套餐用户的数据访问
    - 普通用户创建房间时，只能使用“默认套餐（PLUS）”；管理员可指定任意套餐
- `ChatRoomMemberEntity`（房间成员关系）
  - 字段：`id`, `roomId`, `userId`, `role(OWNER|ADMIN|MEMBER)`, 公共字段
  - 规则：唯一 `(roomId, userId)`；创建房间后自动插入 `OWNER`
- `ChatMessageEntity`（消息）
  - 字段：`id`, `roomId`, `senderId`, `content(TEXT)`, `quotedMessageId?`, `mentionedUserIds(JSONB)`, `createTime`, `updateTime`, `deletedAt`
  - 规则：
    - “引用”消息必须归属于同一房间（跨房间引用禁止）
    - “@艾特”存储为用户ID列表（`mentionedUserIds`），后续用于通知

说明：所有实体均继承 `org.xhy.community.domain.common.entity.BaseEntity`，主键 `String(UUID)`，软删除字段 `deletedAt`。

### 3.2 值对象/枚举（ValueObject）
- `ChatRoomRole`：`OWNER, ADMIN, MEMBER`
  - 按项目规范新增 `ChatRoomRoleConverter`（枚举 <-> VARCHAR），并在 `MyBatisTypeHandlerConfig` 注册。

### 3.3 Repository（继承 BaseMapper）
- `ChatRoomRepository extends BaseMapper<ChatRoomEntity>`
- `ChatRoomMemberRepository extends BaseMapper<ChatRoomMemberEntity>`
- `ChatMessageRepository extends BaseMapper<ChatMessageEntity>`

### 3.4 领域服务（DomainService）
- `ChatRoomDomainService`
  - `ChatRoomEntity createRoom(ChatRoomEntity room, String operatorId, AccessLevel accessLevel)`
    - USER：强制/校验 `subscriptionPlanId` 为“默认套餐（PLUS）”；ADMIN：允许任意套餐
    - 写入房间与 `OWNER` 成员关系
  - `boolean isMember(String roomId, String userId)`
  - `ChatRoomEntity getById(String roomId)`
- `ChatMessageDomainService`
  - `ChatMessageEntity sendMessage(ChatMessageEntity message, AccessLevel accessLevel)`
    - 校验：发送者是成员；引用消息归属同房间
    - 保存消息；发布“消息创建事件”（见 §7）
  - `IPage<ChatMessageEntity> pageMessages(String roomId, Integer pageNum, Integer pageSize, String operatorId, AccessLevel accessLevel)`
    - USER：仅允许查询自己加入的房间；ADMIN：可查询任意房间

> 领域层仅做业务规则校验，不做格式校验（如空值/长度/邮箱格式等）。

## 四、应用层设计（Application）
### 4.1 应用服务（AppService）
- 用户端
  - `ChatRoomAppService`
    - `ChatRoomDTO createRoom(CreateChatRoomRequest request, String userId)`
      - 通过 `SystemConfigDomainService.getDefaultSubscriptionConfig()` 获取默认套餐ID（PLUS），USER 强制使用；ADMIN 可透传请求的套餐ID
  - `ChatMessageAppService`
    - `ChatMessageDTO sendMessage(SendMessageRequest request, String userId)`
      - 解析 `@昵称`（若由前端完成 disambiguation，可直接传 `mentionedUserIds`），批量用 `UserDomainService` 做昵称->ID 映射
      - 组装实体并调用 `ChatMessageDomainService.sendMessage`
    - `IPage<ChatMessageDTO> pageMessages(RoomMessageQueryRequest request, String userId)`
- 管理端
  - `AdminChatRoomAppService`
    - `ChatRoomDTO createRoom(AdminCreateChatRoomRequest request, String adminId)`（允许指定任意 `subscriptionPlanId`）

说明：
- Application 层做流程编排与 DTO 转换，事务在 Application 层管理；不直接调用 Repository；不使用 `UserContext`（Controller 负责取 userId 并传入）。

### 4.2 DTO 与 Assembler（静态方法）
- `ChatRoomDTO`：`id,name,subscriptionPlanId,creatorId,memberCount?,createTime`
- `ChatMessageDTO`：`id,roomId,senderId,content,quotedMessageId,mentionedUserIds,createTime`
- 管理端 DTO 可扩展 `creatorName/senderName/planName` 等，按照现有模式在 App 层批量补齐关联数据后再组装。
- `ChatRoomAssembler` / `ChatMessageAssembler`：使用 `BeanUtils.copyProperties`。

## 五、权限与套餐隔离
### 5.1 AccessLevel 与成员校验
- 单一查询方法接收 `AccessLevel`，在 Domain 层通过条件控制是否附加用户隔离（与现有模式一致）。
- 读写前校验是否成员；管理员可越权查询但发言仍需先加入房间（建议）。

### 5.2 套餐隔离策略
- 房间强关联 `subscription_plans.id`，实现跨套餐数据隔离。
- 默认套餐（普通用户创建房间使用）：读取 `SystemConfigType.DEFAULT_SUBSCRIPTION_PLAN`（`SystemConfigDomainService.getDefaultSubscriptionConfig()`）。
- 管理员创建时可指定任意 `subscriptionPlanId`。

### 5.3 接口功能权限码（可选）
- Controller 增加注解 `@RequiresPlanPermissions`：
  - `CHAT_ROOM_CREATE`, `CHAT_ROOM_LIST`, `CHAT_ROOM_JOIN`,
  - `CHAT_MESSAGE_SEND`, `CHAT_MESSAGE_PAGE`
- 真实安全边界在后端（拦截器 + Domain 校验）。

## 六、数据库设计（Flyway / PostgreSQL）
迁移文件：`src/main/resources/db/migration/V70__Create_chat_tables.sql`

```sql
-- chat_rooms
CREATE TABLE IF NOT EXISTS chat_rooms (
  id              VARCHAR(36) PRIMARY KEY,
  name            VARCHAR(100) NOT NULL,
  description     TEXT,
  subscription_plan_id VARCHAR(36) NOT NULL,
  creator_id      VARCHAR(36) NOT NULL,
  create_time     TIMESTAMP NOT NULL DEFAULT NOW(),
  update_time     TIMESTAMP NOT NULL DEFAULT NOW(),
  deleted_at      TIMESTAMP NULL
);
CREATE INDEX IF NOT EXISTS idx_chat_rooms_plan ON chat_rooms (subscription_plan_id);

-- chat_room_members
CREATE TABLE IF NOT EXISTS chat_room_members (
  id          VARCHAR(36) PRIMARY KEY,
  room_id     VARCHAR(36) NOT NULL,
  user_id     VARCHAR(36) NOT NULL,
  role        VARCHAR(20)  NOT NULL,
  create_time TIMESTAMP NOT NULL DEFAULT NOW(),
  update_time TIMESTAMP NOT NULL DEFAULT NOW(),
  deleted_at  TIMESTAMP NULL,
  CONSTRAINT uk_room_user UNIQUE (room_id, user_id)
);
CREATE INDEX IF NOT EXISTS idx_chat_room_members_room ON chat_room_members (room_id);
CREATE INDEX IF NOT EXISTS idx_chat_room_members_user ON chat_room_members (user_id);

-- chat_messages
CREATE TABLE IF NOT EXISTS chat_messages (
  id                VARCHAR(36) PRIMARY KEY,
  room_id           VARCHAR(36) NOT NULL,
  sender_id         VARCHAR(36) NOT NULL,
  content           TEXT        NOT NULL,
  quoted_message_id VARCHAR(36) NULL,
  mentioned_user_ids JSONB      NULL,
  create_time       TIMESTAMP   NOT NULL DEFAULT NOW(),
  update_time       TIMESTAMP   NOT NULL DEFAULT NOW(),
  deleted_at        TIMESTAMP   NULL
);
CREATE INDEX IF NOT EXISTS idx_chat_messages_room_time ON chat_messages (room_id, create_time DESC);
-- 如引用查询不高频，可暂不建索引；需要时启用：
-- CREATE INDEX IF NOT EXISTS idx_chat_messages_quoted ON chat_messages (quoted_message_id);
```

说明：
- 软删除：与全局约定一致，查询无需显式 `deleted_at` 条件（框架已处理）。
- `mentioned_user_ids` 使用 `JSONB`，由 `UniversalListConverter` 进行序列化/反序列化。
- 遵循“非高频字段不要加索引”的规范，上述索引均为高频查询路径。

## 七、事件与通知（扩展点）
两种接入方式（二选一，推荐 A）：
- A. 复用现有 `ContentPublishedEvent` 流程
  - 扩展 `ContentType` 新增 `CHAT_MESSAGE`
  - 在 `ChatMessageDomainService.sendMessage` 成功后发布 `ContentPublishedEvent(CHAT_MESSAGE, messageId, senderId)`
  - 在 `ContentEventDispatcher` 中新增 Chat 消息 Handler：根据 `mentionedUserIds` 组装接收者，调用 `NotificationDomainService.send` 发送站内/邮箱通知
  - 可新增 `NotificationType.CHAT_MESSAGE_MENTION`（模板化文案）
- B. 自定义 `ChatMessageCreatedEvent`（若不希望影响通用 ContentType）
  - Application 层编写独立 Listener，逻辑同上

本阶段可先完成 A 的事件发布与空 Handler，后续补齐通知模板。

## 八、异常设计
新增模块错误码 `ChatErrorCode`（位于 `org.xhy.community.infrastructure.exception`）：
- `ROOM_NOT_FOUND`：房间不存在
- `UNAUTHORIZED_ROOM_ACCESS`：无权访问房间/非成员操作
- `INVALID_PLAN_FOR_USER`：普通用户指定了非默认套餐
- `MESSAGE_NOT_FOUND`：消息不存在
- `QUOTE_CROSS_ROOM_NOT_ALLOWED`：跨房间引用禁止
- `SENDER_NOT_MEMBER`：非成员无法发言

Domain/App 层抛出 `BusinessException(ChatErrorCode.XXX)`。

## 九、类型转换与配置
- 新增 `ChatRoomRoleConverter`（枚举 <-> VARCHAR），并在 `MyBatisTypeHandlerConfig` 注册：
  - `typeHandlerRegistry.register(ChatRoomRole.class, new ChatRoomRoleConverter());`
- `mentioned_user_ids` 字段：在 `ChatMessageEntity` 上标注 `@TableField(typeHandler = UniversalListConverter.class)`，DB 列类型 `JSONB`。

## 十、API 设计大纲（后续迭代）
仅规划，不在本阶段实现 Controller；参数校验在 API 层完成，`PageRequest` 继承用于分页：
- 用户端 `/api/user/chat-rooms`
  - `POST /` 创建房间（USER 默认套餐，ADMIN 可指定）
  - `GET /` 我的房间列表
  - `POST /{roomId}/join` 加入房间
- 用户端 `/api/user/chat-rooms/{roomId}/messages`
  - `POST /` 发送消息（支持 `quotedMessageId`、`mentionedUserIds`/`@昵称`）
  - `GET /` 分页拉取消息（request 继承 `PageRequest`）
- 管理端 `/api/admin/chat-rooms`
  - `POST /` 创建房间（可指定任意套餐）

权限建议在 Controller 添加：`@RequiresPlanPermissions`（`CHAT_ROOM_CREATE`, `CHAT_MESSAGE_SEND` 等）。

## 十一、非功能性要求（NFR）
- 性能：消息分页按 `room_id + create_time` 索引；避免 N+1（批量查询作者/昵称映射）。
- 安全：发送与拉取必须是成员；管理员越权仅限读，发言需加入。
- 限流：发送消息频控（后续在 Infra 增加 `RateLimiter` 拦截）。
- 内容合规：预留与内容审核（敏感词/图片）的集成点。
- 数据保留：后续按需增加过期清理或归档策略。

## 十六、协议选择与实时推送（补充说明）
本方案刻意将“发送（上行）”与“接收（下行）”解耦：

- 发送消息使用 HTTP `POST`（推荐做法）
  - 事务与超时边界清晰：单次请求内完成鉴权、业务校验、持久化与事件发布
  - 易于做幂等与重试：客户端带 `Idempotency-Key`/`clientMessageId`，服务端去重后返回相同结果
  - 与现有架构/网关/审计对齐：沿用统一鉴权链路、WAF/灰度/限流策略更成熟
  - 移动网络更稳健：短连接天然适配弱网与断线自动重试

- 实时送达使用 WebSocket 或 SSE（下行推送）
  - 客户端建立到 `/ws/chat`（示例）的长连接，订阅房间消息推送
  - 服务端在“消息创建事件”后，将消息广播到对应房间的在线订阅者
  - 未在线/断线用户以分页 `GET` 作为兜底拉取路径（与上文 API 大纲一致）

- 可选：支持 WebSocket 上行发送（非必需）
  - Infra 层实现 `ChatWebSocketGateway`，仅调用 `ChatMessageAppService.sendMessage`，遵循“Infra → Application”的分层规范
  - HTTP 与 WS 统一复用同一 AppService，确保幂等一致性（同一 `clientMessageId` 返回同一结果）
  - 仍推荐“HTTP 发、WS/SSE 收”，以降低长连接写入带来的背压与限流复杂度

示例（仅用于说明消息格式，最终以请求对象为准）：

```json
// HTTP POST /api/user/chat-rooms/{roomId}/messages
{
  "content": "hello",
  "quotedMessageId": null,
  "mentionedUserIds": ["u1","u2"],
  "clientMessageId": "c-mid-170000000001" // 用于幂等去重（可选）
}

// WebSocket 上行（可选能力，内部仍调用 AppService）
{
  "type": "SEND",
  "roomId": "r1",
  "content": "hello",
  "clientMessageId": "c-mid-170000000001"
}
```

权衡总结：
- HTTP 发送利于幂等/审计/限流/弱网重试；WS/SSE 用于低延时下行推送
- 如需纯 WS，保持“Infra 调 AppService”的分层，避免直接触达 Domain；并与 HTTP 共用幂等策略

## 十七、WebSocket 推送实现细节（可落地）
本节细化“如何把消息实时推送给在线的房间成员”。

- 鉴权与建链
  - 握手地址：`/ws/chat?token=JWT`
  - 自定义 `HandshakeInterceptor` 使用 `JwtUtil` 解析 `token`，将 `userId` 放入 `WebSocketSession` 的 attributes
  - 不使用 `UserContext`（仅限 Controller 使用），WS 网关直接解析 token

- 订阅与会话管理
  - 上行命令：
    - `SUBSCRIBE { roomId }`：订阅房间；服务端校验成员资格（调用 AppService），通过后把连接加入 `roomId -> sessions` 的映射
    - `UNSUBSCRIBE { roomId }`：取消订阅并移除映射
    - `HEARTBEAT`：心跳包，服务端返回 `PONG`
    - `SEND {...}`（可选）：通过 WS 发送消息（内部仍调用 `ChatMessageAppService.sendMessage`），与 HTTP 统一幂等
  - 断开时自动清理全部订阅

- 广播流程
  - 事务提交后在 Application 层发布 `ChatMessageCreated` 事件（`@TransactionalEventListener(AFTER_COMMIT)`）
  - 基础设施层的 `ChatWebSocketGateway` 监听事件，查询 `roomId` 的在线连接集合
  - 广播 `type=message` 的 JSON 到该房间在线用户；可选择排除发送者会话以避免重复（或广播给全部，前端按 `id` 去重）

- 集群与扩展
  - 集群广播：使用 Redis Pub/Sub 通道 `chat:room:{roomId}` 在节点间传播，WS 节点只向本机会话转发
  - 背压控制：每连接发送队列上限，超限可丢弃或断开；上行 `SEND` 亦需限流
  - 兜底拉取：离线用户使用 `GET /messages` 增量拉取（`sinceId` 或 `createdAfter`）

- 消息格式（示例）
  - 上行：
    ```json
    { "type": "SUBSCRIBE", "roomId": "r1" }
    { "type": "UNSUBSCRIBE", "roomId": "r1" }
    { "type": "HEARTBEAT" }
    { "type": "SEND", "roomId": "r1", "content": "hi", "clientMessageId": "c-mid-1" }
    ```
  - 下行：
    ```json
    { "type": "message", "payload": { "id": "m1", "roomId": "r1", "senderId": "u2", "content": "hi", "createTime": "..." } }
    { "type": "system", "payload": { "roomId": "r1", "onlineCount": 5 } }
    { "type": "pong" }
    ```

- 代码落地位置（建议放置，当前仅文档说明）
  - `infrastructure/ws/ChatWebSocketConfig`：注册 `/ws/chat` 端点与握手拦截
  - `infrastructure/ws/AuthHandshakeInterceptor`：解析 `token` → `userId`
  - `infrastructure/ws/ChatLiveSessionRegistry`：维护 `roomId -> sessions` 映射与广播
  - `infrastructure/ws/ChatWebSocketGateway`：命令解析、订阅管理、事件广播，Infra → Application
  - `infrastructure/ws/ChatMessageSender`：Infra 的发送抽象，由 Application 提供实现，内部再调 `ChatMessageAppService`

## 十八、幂等支持与请求对象
- HTTP 与 WS 上行均支持 `clientMessageId`，服务端做去重；建议约束：同一 `senderId + roomId + clientMessageId` 只接受一次
- App 层请求对象补充：`application/chat/dto/SendMessageRequest#clientMessageId`
- DB（可选增强）：为 `chat_messages` 增加列 `client_message_id VARCHAR(64)`，并建唯一约束 `(room_id, sender_id, client_message_id)`；弱网重复提交时返回已存在的消息

## 十二、迭代计划
- M1（当前 PR）
  - Flyway 迁移：`V70__Create_chat_tables.sql`
  - 实体/枚举/Converter 与 Repository 骨架
  - DomainService 与 AppService 方法签名与基础实现
  - Assembler/DTO 与错误码定义
- M2
  - 事件发布与通知打通（`ContentType.CHAT_MESSAGE` + Mention 通知模板）
  - Controller 与接口权限码接入
- M3
  - 房间管理（成员角色变更、踢人、禁言等）与审计日志
- M4
  - 富文本/图片消息、消息编辑/删除、引用快照

## 十三、测试策略
- Domain 单元测试：成员校验、跨房间引用、套餐隔离、分页查询条件。
- Repository 映射测试：`UniversalListConverter` 序列化/反序列化 `mentioned_user_ids`。
- 集成测试（后续）：发送消息→发布事件→通知入库的端到端流程。

## 十四、与项目规范对齐点
- Assembler 使用 `BeanUtils.copyProperties`，放置于 Application 层 `assembler` 包，静态方法。
- 依赖注入使用构造函数。
- Repository 仅继承 `BaseMapper`，不写自定义 SQL。
- Application 不直接使用 Repository；UserContext 只允许在 Controller 层使用。
- 所有 ID 类型均为 `String`；分页请求对象继承 `PageRequest`。

## 十五、风险与备选方案
- @昵称歧义：若昵称不唯一，建议前端 disambiguation，后端接收已解析的 `mentionedUserIds`；或在 App 层通过 `UserDomainService` 批量做“昵称->用户ID”的容错映射并返回无法匹配项。
- 引用稳定性：若未来支持消息编辑/删除，建议引入“引用快照”字段，保证历史展示稳定。
- 通知模板：首版可仅发站内消息，邮件模板后续补齐。

---

如无异议，下一步将提交：
- `V70__Create_chat_tables.sql`
- `domain/chat/...` 实体、枚举、Repository、DomainService
- `application/chat/...` AppService、DTO、Assembler
- `infrastructure/config/MyBatisTypeHandlerConfig` 注册 `ChatRoomRoleConverter`
- `infrastructure/exception/ChatErrorCode`

并按“管理员/用户接口分离、权限码接入、分页请求继承 PageRequest”的规范推进。
