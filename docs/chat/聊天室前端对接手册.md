# 聊天室前端对接手册（HTTP + WebSocket）

## 1. 概述
- 目标：前端在聊天室页面实现“初始化消息 + 实时推送 + 发送消息 + 离开清理”。
- 分层说明：
  - 加入房间（Join）：业务层持久化成员关系（HTTP）。
  - 订阅房间（Subscribe）：实时通道层声明接收该房间消息（WebSocket），非持久化。
  - 发送消息：推荐使用 HTTP，稳定且易重试；实时下行推送由 WS 负责。

## 2. 鉴权与握手
- 认证：JWT（登录后获得）。
- HTTP：在 Header 携带 `Authorization: Bearer <JWT>`。
- WebSocket：`ws(s)://<host>/ws/chat?token=<JWT>`。
- 握手失败（401）：需刷新登录态或重新获取 token。

## 3. HTTP 接口
- 创建房间（管理员/用户复用）
  - 路由：`POST /api/user/chat-rooms`
  - Body：
    - `name` string(<=128) 必填
    - `description` string(<=2000) 可选
    - `subscriptionPlanId` string 可选，仅管理员可传；普通用户忽略并使用系统默认套餐
  - 返回：`ChatRoomDTO { id,name,description,subscriptionPlanId,creatorId,createTime,updateTime,joined }`

- 加入房间（幂等）
  - 路由：`POST /api/user/chat-rooms/{roomId}/join`
  - 返回：`200 OK`

- 查询房间（全量 + 是否已加入标记）
  - 路由：`GET /api/user/chat-rooms?nameLike=&pageNum=&pageSize=`
  - 返回：分页 `ChatRoomDTO` 列表；`joined` 表示“当前用户是否成员”。

- 发送消息（推荐 HTTP）
  - 路由：`POST /api/user/chat-rooms/{roomId}/messages`
  - Body：
    - `content` string 必填
    - `quotedMessageId` string 可选（引用消息需同房间）
    - `mentionedUserIds` string[] 可选
    - `clientMessageId` string(<=64) 可选（预留：将来用于幂等去重）
  - 返回：`ChatMessageDTO { id,roomId,senderId,content,quotedMessageId,mentionedUserIds,createTime,updateTime }`

- 拉取消息（分页）
  - 路由：`GET /api/user/chat-rooms/{roomId}/messages?pageNum=&pageSize=`
  - 返回：分页 `ChatMessageDTO` 列表（按 `createTime` 降序）。

## 4. WebSocket 协议（WsFrame）
- 通用帧结构：
  ```json
  { "type": "xxx", "payload": { ... } }
  ```
- 上行指令（前端 → 服务端）：
  - 订阅房间：`{"type":"SUBSCRIBE","roomId":"RID"}`
  - 退订房间：`{"type":"UNSUBSCRIBE","roomId":"RID"}`
  - 心跳保活：`{"type":"HEARTBEAT"}`

- 下行帧（服务端 → 前端）：
  - 订阅确认：
    ```json
    { "type": "subscribed", "payload": { "roomId": "RID", "action": "subscribe" } }
    ```
  - 退订确认：
    ```json
    { "type": "unsubscribed", "payload": { "roomId": "RID", "action": "unsubscribe" } }
    ```
  - 心跳响应：
    ```json
    { "type": "pong", "payload": { "serverTime": "2025-10-23T10:10:10Z" } }
    ```
  - 新消息推送（核心）：
    ```json
    { "type": "message", "payload": {
        "id": "MID",
        "roomId": "RID",
        "senderId": "UID",
        "content": "hello",
        "quotedMessageId": null,
        "mentionedUserIds": ["u1","u2"],
        "occurredAt": "2025-10-23T10:10:10"
    }}
    ```
  - 错误：
    ```json
    { "type": "error", "payload": { "code": "UNAUTHORIZED_ROOM_ACCESS", "message": "not a member" } }
    { "type": "error", "payload": { "code": "INVALID_ROOM", "message": "roomId is required" } }
    { "type": "error", "payload": { "code": "UNKNOWN_TYPE", "message": "Unsupported message type: ..." } }
    { "type": "error", "payload": { "code": "BAD_REQUEST", "message": "..." } }
    ```

## 5. 前端对接流程（建议）
- 进入房间页面：
  1) HTTP 首屏：`GET /api/user/chat-rooms/{roomId}/messages?pageNum=1&pageSize=20` 渲染历史
  2) 建立 WS：`ws://<host>/ws/chat?token=<JWT>`
  3) 订阅：发 `SUBSCRIBE`，等待 `subscribed` 确认
  4) 实时增量：收到 `type=message` 推送后，按 `payload.id` 去重并插入列表

- 发送消息（HTTP）：
  - `POST /api/user/chat-rooms/{roomId}/messages` 成功后本地乐观更新（已含服务端生成的 `id`/时间戳）。

- 离开房间/切换页面：
  - 发 `UNSUBSCRIBE`，或直接 `close()`（服务端会自动清理订阅）。

- 断线重连：
  - 重新建 WS + 重新 SUBSCRIBE；随后 HTTP 再拉一页最新消息补齐。

## 6. 示例代码片段（浏览器端）
```js
const token = 'JWT_FROM_LOGIN';
const roomId = 'RID_123';

// 1) HTTP 首屏
await fetch(`/api/user/chat-rooms/${roomId}/messages?pageNum=1&pageSize=20`, {
  headers: { Authorization: `Bearer ${token}` }
}).then(r => r.json()).then(renderPage);

// 2) 建立 WS
const ws = new WebSocket(`${location.origin.replace('http', 'ws')}/ws/chat?token=${token}`);
ws.onopen = () => ws.send(JSON.stringify({ type: 'SUBSCRIBE', roomId }));

ws.onmessage = (e) => {
  const frame = JSON.parse(e.data);
  switch (frame.type) {
    case 'subscribed':
      console.log('Subscribed to', frame.payload.roomId);
      break;
    case 'message':
      renderMessage(frame.payload); // 按 payload.id 去重
      break;
    case 'error':
      console.warn('WS Error', frame.payload);
      break;
    case 'pong':
      // 心跳响应
      break;
  }
};

// 3) 心跳（可选）
setInterval(() => {
  if (ws.readyState === 1) ws.send(JSON.stringify({ type: 'HEARTBEAT' }));
}, 30000);

// 4) 发送消息（HTTP 推荐）
async function send(content) {
  await fetch(`/api/user/chat-rooms/${roomId}/messages`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`
    },
    body: JSON.stringify({ content })
  }).then(r => r.json()).then(({ data }) => renderMessage(data));
}
```

## 7. 常见问题与约束
- 必须是房间成员才能 SUBSCRIBE，否则返回 `UNAUTHORIZED_ROOM_ACCESS`。
- “加入房间”（HTTP，持久化）与“订阅房间”（WS，在线关系）是两步：只有两者满足（成员+订阅），此连接才会收到实时推送。
- 发送消息推荐走 HTTP；WS 当前仅用于下行推送（更稳、更易重试）。
- 去重：前端按 `payload.id` 保证消息不重复渲染。
- 兜底：断线或切后台期间的消息，请用 HTTP GET 分页补拉。

## 8. 调试建议
- 用浏览器 devtools Network 面板观测 WS 帧；或用 `wscat` 等工具建链测试：
  - `wscat -c "ws://<host>/ws/chat?token=<JWT>"`
  - 然后发送：`{"type":"SUBSCRIBE","roomId":"RID"}` 观察 `subscribed` 与 `message` 推送。

---
如需接入“消息幂等”和“Redis Pub/Sub 集群广播”，可在后续迭代开启；前端对接协议不变。

