# 聊天室未读数与已读技术方案（Room Last Seen）

## 1. 背景与目标
- 目标：在聊天室中实现“房间级未读数”与“已读显示”的最小闭环，避免逐条已读的高成本实现。
- 口径：以“用户在某房间的上次进入/阅读时间（Last Seen）”为锚，统计该时间之后产生的消息数量作为未读数；已读判断以消息时间与 Last Seen 比较。
- 不做：逐条消息已读表（user_message_reads），除非后续确有强一致回执/审计需求。

## 2. 口径定义
- 房间未读数：count(messages where room_id = ? and create_time > lastSeenAt(user, room))。
- 已读渲染（当前用户视角）：消息 create_time ≤ lastSeenAt → 已读；否则未读。
- 清零/推进时机：进入房间加载消息后（或滚动到更靠后位置时），更新用户在该房间的 lastSeenAt。

## 3. 总体方案（复用“列表级未读”的实现模式）
- 思路与项目现有的 `UserLastSeenEntity`（频道级）一致，但维度从“频道”变为“(userId, roomId)”二元组。
- 依赖现有 `chat_messages` 的 `(room_id, create_time)` 索引进行快速统计。

## 4. 数据模型（PostgreSQL / Flyway）
- 新表：`user_chat_room_last_seen`
  ```sql
  CREATE TABLE IF NOT EXISTS user_chat_room_last_seen (
    id            VARCHAR(36) PRIMARY KEY,
    user_id       VARCHAR(36) NOT NULL,
    room_id       VARCHAR(36) NOT NULL,
    last_seen_at  TIMESTAMP   NOT NULL,
    create_time   TIMESTAMP   NOT NULL DEFAULT NOW(),
    update_time   TIMESTAMP   NOT NULL DEFAULT NOW(),
    deleted_at    TIMESTAMP   NULL
  );
  CREATE UNIQUE INDEX IF NOT EXISTS uk_user_room_last_seen
    ON user_chat_room_last_seen (user_id, room_id)
    WHERE deleted_at IS NULL;
  ```
- 说明：
  - 逻辑删除沿用全局 `deleted_at` 约定；查询无需显式增加删除条件。
  - 唯一索引保证 `(user_id, room_id)` 维度的幂等操作。

## 5. 领域与应用设计
- Domain：`ChatRoomReadDomainService`
  - `getOrInit(userId, roomId)`：无则以 `now` 初始化，幂等兜底（唯一约束冲突回退查询）。
  - `getLastSeenAt(userId, roomId)`：读取 lastSeenAt，可为 null。
  - `updateLastSeen(userId, roomId, serverNow)`：防回拨更新（仅当现有值为空或 ≤ serverNow 时更新）。
- Domain：`ChatMessageDomainService`
  - `countSince(roomId, since)`：统计房间在 `since` 之后的消息数量；`since` 为 null 表示视为全部未读（或按照“加入时间”为锚点，见 §9）。
- App：`ChatUnreadAppService`
  - `getUnreadCount(roomId, userId)`：读取 lastSeenAt → `countSince`。
  - `visitRoom(roomId, userId)`：进入房间后清零（更新 lastSeenAt）。

## 6. 接口设计（HTTP）
- 查询未读数
  - `GET /api/app/chat-rooms/{roomId}/unread-count`
  - 鉴权与权限：登录且必须是房间成员。
  - 返回：`Long`（未读数量）。
- 清零（进入房间）
  - `PUT /api/app/chat-rooms/{roomId}/visit`
  - 鉴权与权限：登录且必须是房间成员。
  - 语义：将 lastSeenAt 更新为 `serverNow`（或选项：首屏最后一条消息的 createTime，见 §7）。
- 可选批量接口（列表页展示多个房间未读）
  - `GET /api/app/chat-rooms/unread-counts?roomIds=RID1,RID2,...`
  - 返回：`Map<roomId, Long>`。
  - 实现：先批量读 lastSeenAt，再逐房间 `countSince`；房间数通常有限，性能可接受。

## 7. 清零锚点选择
- 简化方案：`serverNow`（推荐起步）
  - 实现简单；极短时间窗的新增消息由 WS 推送兜底渲染，体验可接受。
- 更严谨方案：首屏最后一条消息的 `createTime`
  - 需要前端把“首屏最后一条消息的 id/time”回传；后端按该时间推进 lastSeenAt。
  - 可在后续迭代增加一个 `PUT /visit?lastMessageId=...` 方案。

## 8. WebSocket 与未读联动（可选增强）
- 进入房间后 `PUT /visit` 成功，可发布 `ChatRoomReadUpdatedEvent(roomId, userId, lastSeenAt)`，由 WS 下行一条 `type=read` 的帧（只在当前房间广播）：
  ```json
  { "type": "read", "payload": { "roomId": "RID", "userId": "UID", "lastSeenAt": "..." } }
  ```
- 用途：同房间在线成员可实时看到“某用户已读到这里”的进度（如需回执展示）。
- 注意：该事件是可选增强，不影响未读计数核心功能。

## 9. 一致性与边界
- 加入房间的 lastSeen 初始化：
  - 建议在“加入房间”时（或首次查询未读时）将 `lastSeenAt` 初始化为 `now`，使“加入后未读=0”。
  - 若需要“加入后也算历史消息为未读”，可关闭此初始化。
- 防回拨：`updateLastSeen` 必须保证单调不减（仅允许向前推进）。
- 计数口径：`create_time > lastSeenAt` 作为“新消息”；如果采用“首屏最后消息时间”作为锚点，也遵循同一比较。
- 非成员：不得查询/清零房间未读。
- 软删除：`chat_messages` 及 `user_chat_room_last_seen` 均受全局 `deleted_at` 管控。

## 10. 性能与索引
- 计数走 `chat_messages (room_id, create_time)` 复合索引（已存在）。
- `user_chat_room_last_seen` 加唯一索引 `(user_id, room_id)`（where 未删除）。
- 批量查询时控制房间数量（前端UI同屏有限，一般 ≤ 50）。
- 暂不引入缓存；如需高频统计，可在 App 层增加本地或 Redis 缓存，命中后再兜底 DB。

## 11. 与现有“列表级未读（UserLastSeen）”的关系
- 模式完全对齐：`getOrInit`、`updateLastSeen`、`防回拨`、`summary/visit` 交互风格。
- 仅维度不同：`channel` → `(userId, roomId)`。

## 12. 后续扩展
- 批量未读接口：供房间列表页显示红点。
- 已读回执（谁已读）：基于成员的 lastSeen 聚合，而非逐条写入，展示“已读人数/读到哪里”。
- 更精细的清零：以“首屏最后一条消息时间”为锚，或“滚动到某条消息后”推进 lastSeen。
- 集群广播：若上线多实例，WS 广播需接入 Redis Pub/Sub（已在聊天室方案文档说明）。

## 13. 前端对接要点
- 进入房间：
  1) HTTP 拉首屏消息列表
  2) 建立 WS 并 SUBSCRIBE 房间
  3) 调用 `PUT /api/app/chat-rooms/{roomId}/visit` 清零（或在列表加载后，将 lastSeen 推进到首屏最后消息时间）
- 显示未读数：`GET /api/app/chat-rooms/{roomId}/unread-count`
- 已读渲染：基于“本地的 lastSeenAt”判断消息是否已读（或由后端返回 isRead 字段，按需扩展）。

---
如需立即落地：可先实现单房间未读统计与清零接口，后续按需增加批量接口与 WS 读取进度推送。

